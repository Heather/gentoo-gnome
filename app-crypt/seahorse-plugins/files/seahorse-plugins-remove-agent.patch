From 7e114290f96700a3c4e06a1515d410beb06f4390 Mon Sep 17 00:00:00 2001
From: Stef Walter <stefw@collabora.co.uk>
Date: Thu, 10 Feb 2011 22:21:44 +0000
Subject: Merge branch 'no-gpg-agent'

---
diff --git a/HACKING b/HACKING
index cf62003..5d71bae 100644
--- a/HACKING
+++ b/HACKING
@@ -6,12 +6,6 @@ with possible enhancements and any current bugs.
 
 Here is a description of the modules:
 
- o agent: GPG Password caching agent. This is compiled into seahorse-daemon. 
-   (See 'daemon' below)
-
- o daemon: Various background servers and processes run in this daemon including
-   the gpg agent, dbus server, etc...
- 
  o data: Data files that need to be processed. Current this is just schemas. They 
    are here because there will be multiple schemas files to separate the app and 
    pgp settings.
@@ -48,18 +42,6 @@ implemented that feature yet, or refusal to implement a given feature. In
 these cases direct use of GPG is permitted. Such cases must be documented 
 below, and must be discussed before hand on the seahorse-devel mailing list.
 
- o seahorse-agent implements a gpg-agent compatible assuan interface. It also
-   depends on figuring out where the GPG home directory is and modifying 
-   GPG options (see below).
-   - agent/*
-   
- o The Backup Keyrings feature accesses the ~/.gnupg/pubring.gpg and 
-   ~/.gnupg/secring.gpg files directly. 
-   - src/seahorse-key-manager.c
-   
- o There is code which modifies the ~/.gnupg/gpg.conf GPG configuration file. 
-   - libseahorse/seahorse-gpg-options.c
-   
  o Photo ID support
    - gpgme_op_edit state machine in libseahorse/seahorse-pgp-key-op.c 
    
diff --git a/Makefile.am b/Makefile.am
index b265ed2..39d4d35 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -2,19 +2,12 @@
 
 ACLOCAL_AMFLAGS = -I m4
 
-if WITH_AGENT
-AGENT_DIR = agent
-else
-AGENT_DIR = 
-endif
-
 SUBDIRS = libseahorse \
           po \
           data \
           help \
           pixmaps \
-          plugins \
-          $(AGENT_DIR)
+          plugins
 
 EXTRA_DIST = \
     AUTHORS \
diff --git a/agent/.gitignore b/agent/.gitignore
deleted file mode 100644
index d70119b..0000000
--- a/agent/.gitignore
+++ b/dev/null
@@ -1,6 +0,0 @@
-/.deps
-/.libs
-
-/Makefile
-/Makefile.in
-/seahorse-agent
diff --git a/agent/Makefile.am b/agent/Makefile.am
deleted file mode 100644
index 9cd941d..0000000
--- a/agent/Makefile.am
+++ b/dev/null
@@ -1,36 +0,0 @@
-uidir = $(datadir)/seahorse-plugins/ui/
-localedir = $(datadir)/locale
-pixmapsdir = $(datadir)/pixmaps/
-
-INCLUDES = -I$(top_builddir) \
-	-I$(top_srcdir) \
-	-I$(top_srcdir)/libseahorse \
-	$(SEAHORSE_CFLAGS) \
-	$(AGENT_CFLAGS) \
-	-DDATA_DIR=\""$(datadir)"\" \
-	-DSEAHORSE_UIDIR=\""$(uidir)"\" \
-	-DLOCALEDIR=\""$(localedir)"\" \
-	-DPIXMAPSDIR=\""$(pixmapsdir)"\" \
-	-DLIBCRYPTUI_API_SUBJECT_TO_CHANGE
-
-bin_PROGRAMS = seahorse-agent
-
-seahorse_agent_SOURCES = seahorse-agent.c seahorse-agent.h seahorse-agent-main.c \
-						 seahorse-agent-actions.c seahorse-agent-cache.c seahorse-agent-prompt.c \
-						 seahorse-agent-io.c seahorse-agent-status.c
-
-seahorse_agent_LDADD = \
-    $(top_builddir)/libseahorse/libseahorse.a \
-    $(SEAHORSE_LIBS)
-
-ui_DATA = \
-	seahorse-agent-cache.xml 
-
-man_MANS = seahorse-agent.1
-
-EXTRA_DIST = \
-	$(man_MANS)			\
-	$(ui_DATA)
-
-CLEANFILES = \
-	*.bak
diff --git a/agent/seahorse-agent-actions.c b/agent/seahorse-agent-actions.c
deleted file mode 100644
index 44ea82f..0000000
--- a/agent/seahorse-agent-actions.c
+++ b/dev/null
@@ -1,247 +0,0 @@
-/*
- * Seahorse
- *
- * Copyright (C) 2004 Stefan Walter
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the
- * Free Software Foundation, Inc.,
- * 59 Temple Place, Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-
-#include <sys/types.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <glib/gi18n.h>
-
-#include "seahorse-gconf.h"
-#include "seahorse-agent.h"
-
-#include <gnome-keyring-memory.h>
-
-/*
- * Implements a queue of SeahorseAgentPassReq items. We can only show one dialog
- * to the user at a time, due to keyboard grabbing issues, but mainly 
- * for the users sanity. 
- */
-
-static GQueue *g_queue = NULL;          /* The queue of SeahorseAgentPassReq items */
-
-/* -----------------------------------------------------------------------------
- * IMPLEMENTATION
- */
-
-/* Encode a password in hex */
-static gchar*
-encode_password (const gchar *pass)
-{
-    static const char HEXC[] = "0123456789abcdef";
-    int j, c;
-    gchar *enc, *k;
-
-    /* Encode the password */
-    c = sizeof (gchar *) * ((strlen (pass) * 2) + 1);
-    k = enc = gnome_keyring_memory_new (gchar, c);
-
-    /* Simple hex encoding */
-    while (*pass) {
-        j = *(pass) >> 4 & 0xf;
-        *(k++) = HEXC[j];
-
-        j = *(pass++) & 0xf;
-        *(k++) = HEXC[j];
-    }
-    
-    return enc;
-}
-
-
-void
-seahorse_agent_actions_init ()
-{
-    g_queue = g_queue_new ();
-}
-
-void
-seahorse_agent_actions_uninit ()
-{
-    if (g_queue) {
-        /* All memory for elements freed below */
-        g_queue_free (g_queue);
-        g_queue = NULL;
-    }
-}
-
-/* Called for the assuan GET_PASSPHRASE command */
-void
-seahorse_agent_actions_getpass (SeahorseAgentConn *rq, guint32 flags, gchar *id,
-                                gchar *errmsg, gchar* prompt, gchar *desc)
-{
-    SeahorseAgentPassReq *pr;
-    const gchar *pass;
-    gchar *enc;
-
-    g_return_if_fail (rq != NULL);
-
-    if (id && !seahorse_gconf_get_boolean (SETTING_AUTH)) {
-        /* 
-         * We don't need authorization, so if we have the password
-         * just reply now, without going to the queue.
-         */
-        if ((pass = seahorse_agent_cache_get (id)) != NULL) {
-            if (flags & SEAHORSE_AGENT_PASS_AS_DATA) {
-                seahorse_agent_io_data (rq, pass);
-                seahorse_agent_io_reply (rq, TRUE, NULL);
-            } else {
-                enc = encode_password (pass);
-                seahorse_agent_io_reply (rq, TRUE, enc);
-                gnome_keyring_memory_free (enc);
-            }
-            return;
-        }
-    }
-
-    /* A new queue item */
-    pr = g_slice_new0 (SeahorseAgentPassReq);
-    pr->flags = flags;
-    pr->id = id ? g_strdup (id) : NULL;
-    pr->errmsg = errmsg ? g_strdup (errmsg) : NULL;
-    pr->prompt = g_strdup (prompt ? prompt : _("Passphrase:"));
-    pr->description = g_strdup (desc ? desc : _("Please enter a passphrase to use."));
-    pr->request = rq;
-    g_queue_push_head (g_queue, pr);
-
-    /* Process the queue */
-    seahorse_agent_actions_nextgui ();
-}
-
-static void
-free_passreq (SeahorseAgentPassReq * pr)
-{
-    if (pr->id)
-        g_free ((gpointer) pr->id);
-    if (pr->errmsg)
-        g_free ((gpointer) pr->errmsg);
-    if (pr->prompt)
-        g_free ((gpointer) pr->prompt);
-    if (pr->description)
-        g_free ((gpointer) pr->description);
-
-    /* Just in case, should already be popped */
-    g_queue_remove (g_queue, pr);
-
-    g_slice_free (SeahorseAgentPassReq, pr);
-}
-
-/* Called when a authorize prompt completes (send back the cached password) */
-void
-seahorse_agent_actions_doneauth (SeahorseAgentPassReq * pr, gboolean authorized)
-{
-    const gchar *pass = NULL;
-
-    g_return_if_fail (pr != NULL);
-
-    if (authorized) {
-        /* 
-         * The password will have been locked in the cache by the 
-         * time we arrive here. The code that checks that the password
-         * exists also locks it into the cache.
-         */
-        g_return_if_fail (pr->id);
-        pass = seahorse_agent_cache_get (pr->id);
-        g_return_if_fail (pass != NULL);
-    }
-
-    seahorse_agent_actions_donepass (pr, pass);
-}
-
-/* Called when a password prompt completes (send back new passord) */
-void
-seahorse_agent_actions_donepass (SeahorseAgentPassReq *pr, const gchar *pass)
-{
-    gchar *enc;
-    
-    if (pass == NULL)
-        seahorse_agent_io_reply (pr->request, FALSE, "111 cancelled");
-    else {
-        if (pr->flags & SEAHORSE_AGENT_PASS_AS_DATA) {
-            seahorse_agent_io_data (pr->request, pass);
-            seahorse_agent_io_reply (pr->request, TRUE, NULL);
-        } else {
-            enc = encode_password (pass);
-            seahorse_agent_io_reply (pr->request, TRUE, enc);
-            gnome_keyring_memory_free (enc);
-        }
-    }
-
-    free_passreq (pr);
-    seahorse_agent_actions_nextgui ();
-}
-
-/* Prompts are queued. This is called to display the next if any */
-void
-seahorse_agent_actions_nextgui ()
-{
-    SeahorseAgentPassReq *pr;
-
-    g_return_if_fail (g_queue != NULL);
-
-    /* If we already have some gui thing going on, then wait */
-    if (seahorse_agent_prompt_have ())
-        return;
-
-    if (g_queue_is_empty (g_queue))
-        return;
-
-    pr = g_queue_pop_tail (g_queue);
-    if (pr != NULL) {
-        /*
-         * Always prompt when we have an error message. If we already
-         * have something in the cache, however, we can just authorize
-         */
-        if (!pr->errmsg && pr->id && seahorse_agent_cache_has (pr->id, TRUE)) {
-            /* Do we need to authorize with the user? */
-            if (seahorse_gconf_get_boolean (SETTING_AUTH))
-                seahorse_agent_prompt_auth (pr);
-
-            /* Simple auto-authorize */
-            else
-                seahorse_agent_actions_doneauth (pr, TRUE);
-        }
-
-        /* Prompt for the password */
-        else {
-            seahorse_agent_prompt_pass (pr);
-        }
-
-        /* 
-         * Once either prompt is done it'll call the 
-         * seahorse_agent_actions_donexxxx functions above
-         */
-    }
-
-    seahorse_agent_actions_nextgui ();
-}
-
-/* Called for the assuan CLEAR_PASSPHRASE request */
-void
-seahorse_agent_actions_clrpass (SeahorseAgentConn * rq, gchar * id)
-{
-    if (id != NULL) {
-        seahorse_agent_cache_clear (id);
-        seahorse_agent_io_reply (rq, TRUE, NULL);
-    }
-}
diff --git a/agent/seahorse-agent-cache.c b/agent/seahorse-agent-cache.c
deleted file mode 100644
index 5bf42a4..0000000
--- a/agent/seahorse-agent-cache.c
+++ b/dev/null
@@ -1,658 +0,0 @@
-/*
- * Seahorse
- *
- * Copyright (C) 2004 Stefan Walter
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the
- * Free Software Foundation, Inc.,
- * 59 Temple Place, Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-#include <sys/types.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-
-#include <glib/gi18n.h>
-
-#include <gnome-keyring.h>
-#include <gnome-keyring-memory.h>
-
-#include "seahorse-gconf.h"
-#include "seahorse-gpgmex.h"
-#include "seahorse-agent.h"
-
-/* -----------------------------------------------------------------------------
- * INTERNAL PASSWORD CACHE
- */
-
-/*
- * Implementation of the password cache. Note that only passwords
- * are stored in secure memory, all else is allocated normally.
- * 
- * Cache items can be locked which guarantees they'll stay around even
- * if their TTL expires. 
- */
-
-/* Override the DEBUG_CACHE switch here */
-/* #define DEBUG_CACHE_ENABLE 0 */
-
-#ifndef DEBUG_CACHE_ENABLE
-#if _DEBUG
-#define DEBUG_CACHE_ENABLE 1
-#else
-#define DEBUG_CACHE_ENABLE 0
-#endif
-#endif
-
-#if DEBUG_CACHE_ENABLE
-#define DEBUG_CACHE(x)     g_printerr x
-#else
-#define DEBUG_CACHE(x)
-#endif
-
-#define UNPARSEABLE_KEY     _("Unparseable Key ID")
-#define UNKNOWN_KEY         _("Unknown/Invalid Key")
-#define TRANSIENT_ID        "TRANSIENTTRANSIENT"
-
-typedef struct sa_cache_t {
-    gchar *id;                  /* The password id */
-    gchar *pass;                /* The password itself (pointer to secure mem) */
-    gchar *desc;                /* A description of the key (parsed below) */
-    gboolean locked;            /* Whether this entry is locked in the cache */
-    time_t stamp;               /* The time which this password was last accessed */
-} sa_cache_t;
-
-static GHashTable *g_cache = NULL;      /* Hash of ids to sa_cache_t */
-static guint g_notify_id = 0;           /* gconf notify id */
-static guint g_timeout_id = 0;          /* timeout of next expire */
-static gpgme_ctx_t g_gpgme_ctx = NULL;  /* GPGME context */
-
-gboolean seahorse_agent_cache_check (gpointer);
-
-/* -----------------------------------------------------------------------------
- */
-
-static gint
-calc_ttl ()
-{
-    if (!seahorse_gconf_get_boolean (SETTING_CACHE)) {
-        /* No caching */
-        return 0;
-    }
-
-    if (seahorse_gconf_get_boolean (SETTING_EXPIRE)) {
-        /* How long to cache. gconf has in minutes, we want seconds */
-        return seahorse_gconf_get_integer (SETTING_TTL) * 60;
-    }
-
-    return -1;
-};
-
-static void
-find_next_expiry (gpointer key, gpointer value, gpointer user_data)
-{
-    sa_cache_t *it = (sa_cache_t *) value;
-    time_t *next = (time_t*)user_data;
-
-    if (*next < it->stamp)
-        *next = it->stamp;
-}
-
-/* Called to calculate and setup next expiry timeout */
-static void 
-setup_next_expiry (gboolean nextonly)
-{
-    time_t now, first = 0;
-    gint ms, ttl;
-
-    if (g_hash_table_size (g_cache) == 0)
-        return;
-    ttl = calc_ttl ();
-    if (ttl == -1) /* cache indefinitely */
-        return;
-
-    g_hash_table_foreach (g_cache, find_next_expiry, &first);
-    if (!first)
-        return;
-
-    if (g_timeout_id)
-        g_source_remove (g_timeout_id);
-    now = time (NULL);
-    first += ttl;
-
-    /* Already expired, so clear in a second */
-    if (!nextonly && first <= now)
-        first = now;
-
-    ms = ((first - now) + 1) * 1000;
-    g_timeout_id = g_timeout_add (ms, seahorse_agent_cache_check, NULL);
-
-    DEBUG_CACHE (("[cache] next expiry in %d seconds\n", ms / 1000));
-}
-
-
-/* Check each cache item for expiry */
-static gboolean
-cache_enumerator (gpointer key, gpointer value, gpointer user_data)
-{
-    sa_cache_t *it = (sa_cache_t *) value;
-    gint ttl = *((gint *) user_data);
-
-    if (!it->locked) {
-     
-        /* Clear all items? */
-        if (ttl == 0)
-            return TRUE;
-
-        /* Is expired? */
-        else if (time (NULL) > it->stamp + ttl)
-            return TRUE;
-            
-        /* Is transient? */
-        if (strcmp (it->id, TRANSIENT_ID) == 0)
-            return TRUE;
-    }
-
-    return FALSE;
-}
-
-/* Check the cache for expired items */
-gboolean
-seahorse_agent_cache_check (gpointer unused)
-{
-    g_timeout_id = 0;
-
-    if (!g_cache)
-        return FALSE;
-
-    if (g_hash_table_size (g_cache) > 0) {
-        gint ttl = calc_ttl ();
-        /* negative means cache indefinitely */
-        if (ttl != -1) {
-            if (g_hash_table_foreach_remove (g_cache, cache_enumerator, &ttl) > 0) {
-                DEBUG_CACHE (("[cache] expired cached secrets\n"));
-                seahorse_agent_status_update ();
-                setup_next_expiry (TRUE);
-            }
-        }
-    }
-
-    return FALSE;
-}
-
-/* Callback to free a cache item */
-static void
-destroy_cache_item (gpointer data)
-{
-    sa_cache_t *it = (sa_cache_t *) data;
-    if (it) {
-        if (it->id)
-            g_free (it->id);
-
-        if (it->desc)
-            g_free (it->desc);
-
-        if (it->pass)
-            gnome_keyring_memory_free (it->pass);
-
-        g_slice_free (sa_cache_t, it);
-    }
-}
-
-/* Called when the AUTH gconf key changes */
-static void
-gconf_notify (GConfClient *client, guint id, GConfEntry *entry, gpointer data)
-{
-	/* Clear the cache when someone changes the gconf AUTH setting to false */
-	if (g_str_equal (SETTING_AUTH, gconf_entry_get_key (entry))) {
-        if (!gconf_value_get_bool (gconf_entry_get_value (entry)))
-			seahorse_agent_cache_clearall (NULL);
-	}
-
-    /* TTL setting may have changed, so... */
-    setup_next_expiry (FALSE);
-}
-
-/* Initialize the cache */
-void
-seahorse_agent_cache_init ()
-{
-    gpgme_protocol_t proto = GPGME_PROTOCOL_OpenPGP;
-    gpgme_error_t err;
- 
-    if (g_cache == NULL) {
-        g_cache =
-            g_hash_table_new_full (g_str_hash, g_str_equal, NULL, destroy_cache_item);
-
-        gpgme_check_version (NULL);
-        err = gpgme_engine_check_version (proto);
-        g_return_if_fail (GPG_IS_OK (err));
-        
-        err = gpgme_new (&g_gpgme_ctx);
-        g_return_if_fail (GPG_IS_OK (err));
-       
-        err = gpgme_set_protocol (g_gpgme_ctx, proto);
-        g_return_if_fail (GPG_IS_OK (err));
-        
-        /* Listen for changes on the AUTH key */
-        g_notify_id = seahorse_gconf_notify (SETTING_AUTH, gconf_notify, NULL);
-    }
-}
-
-/* Uninitialize and free up cache memory */
-void
-seahorse_agent_cache_uninit ()
-{
-    if (g_cache) {
-        g_idle_remove_by_data (g_cache);
-        g_hash_table_destroy (g_cache);
-        g_cache = NULL;
-    }
-    
-    if (g_notify_id) {
-        seahorse_gconf_unnotify (g_notify_id);
-        g_notify_id = 0;
-    }
-
-    if (g_timeout_id) {
-        g_source_remove (g_timeout_id);
-        g_timeout_id = 0;
-    }
-    
-    if (g_gpgme_ctx) {
-        gpgme_release (g_gpgme_ctx);
-        g_gpgme_ctx = NULL;
-    }
-}
-
-/* Retrieve a password from the cache */
-const gchar *
-seahorse_agent_internal_get (const gchar *id)
-{
-    sa_cache_t *it;
-
-    g_assert (g_cache != NULL);
-
-    /* Always make sure the cache is properly purged before answering */    
-    seahorse_agent_cache_check (NULL);
-
-    if (id == NULL)
-        id = TRANSIENT_ID;
-
-    it = g_hash_table_lookup (g_cache, id);
-    if (it) {
-        /* Always updates the stamp when password retrieve */
-        it->stamp = time (NULL);
-
-        /* Locks are always one off, so unset */
-        if (it->locked)
-            it->locked = FALSE;
-            
-        return it->pass;
-    }
-
-    return NULL;
-}
-
-/* Check if a given id is in the cache, and lock if requested */
-gboolean
-seahorse_agent_internal_has (const gchar *id, gboolean lock)
-{
-    sa_cache_t *it;
-
-    g_assert (g_cache != NULL);
-
-    /* Always make sure the cache is properly purged before answering */    
-    seahorse_agent_cache_check (NULL);
-        
-    if (id == NULL)
-        id = TRANSIENT_ID;
-
-    it = g_hash_table_lookup (g_cache, id);
-    if (it) {
-        if (lock)
-            it->locked = TRUE;
-        return TRUE;
-    }
-
-    return FALSE;
-}
-
-/* Remove given id from the cache */
-void
-seahorse_agent_internal_clear (const gchar *id)
-{
-    if (id == NULL)
-        id = TRANSIENT_ID;
-        
-    g_assert (g_cache != NULL);
-
-    /* Note that we ignore locks in this case, it was a specific request */
-    g_hash_table_remove (g_cache, id);
-
-    /* UI hooks */
-    seahorse_agent_status_update ();
-    setup_next_expiry (FALSE);
-}
-
-/* Callback for clearing all items */
-static gboolean
-remove_cache_item (gpointer key, gpointer value, gpointer user_data)
-{
-    sa_cache_t *it = (sa_cache_t*) value;
-
-    /* 
-     * This is a simple callback for removing all 
-     * items from a GHashTable. returning TRUE removes. 
-     */
-    return !it->locked;
-}
-
-/* Clear all items in the cache */
-void
-seahorse_agent_cache_clearall ()
-{
-    g_assert (g_cache != NULL);
-
-    if (g_hash_table_foreach_remove (g_cache, remove_cache_item, NULL) > 0) {
-        seahorse_agent_status_update ();
-        setup_next_expiry (FALSE);
-    }
-}
-
-
-/* Set a password in the cache. encode and lock if requested */
-void
-seahorse_agent_internal_set (const gchar *id, const gchar *pass, gboolean lock)
-{
-    gboolean allocated = FALSE;
-    gboolean cache;
-    sa_cache_t *it;
-
-    if (id == NULL)
-        id = TRANSIENT_ID;
-
-    g_return_if_fail (pass != NULL);
-
-    /* Whether to cache passwords or not */
-    cache = seahorse_gconf_get_boolean (SETTING_CACHE);
-
-    /* No need to even bother the cache in this case */
-    if (!cache && !lock)
-        return;
-
-    g_assert (g_cache != NULL);
-
-    it = g_hash_table_lookup (g_cache, id);
-
-    if (!it) {
-        /* Allocate and initialize a new cache item */
-        it = g_slice_new0 (sa_cache_t);
-        it->id = g_strdup (id);
-        allocated = TRUE;
-    }
-
-    g_assert (it->id != NULL);
-
-    /* Work with the password */
-    if (it->pass)
-        gnome_keyring_memory_free (it->pass);
-    it->pass = gnome_keyring_memory_alloc (strlen (pass) + 1);
-    strcpy (it->pass, pass);
-
-    /* If not caching set to the epoch which should always expire */
-    it->stamp = cache ? time (NULL) : 0;
-    it->locked = lock ? TRUE : FALSE;
-
-    if(allocated)
-        g_hash_table_replace (g_cache, it->id, it);
-
-    /* UI hooks */
-    seahorse_agent_status_update ();
-    setup_next_expiry (FALSE);
-}
-
-/* Returns number of passwords in the cache */
-guint
-seahorse_agent_cache_count ()
-{
-    g_assert (g_cache != NULL);
-    return g_hash_table_size (g_cache);
-}
-
-static gchar*
-extract_key_name (gpgme_key_t key)
-{
-    g_return_val_if_fail (key && key->uids && key->uids->uid, g_strdup (""));
-    
-    /* If not utf8 valid, assume latin 1 */
-    if (g_utf8_validate (key->uids->uid, -1, NULL))
-        return g_strdup (key->uids->uid);
-    
-    return g_convert (key->uids->uid, -1, "UTF-8", "ISO-8859-1", NULL, NULL, NULL);
-}
-
-static gchar*
-build_key_name (const gchar *id)
-{
-    gpgme_error_t gerr;
-    gpgme_key_t key;
-    gchar *ret;
-    
-    g_return_val_if_fail (g_gpgme_ctx, g_strdup (""));
-	    
-    gerr = gpgme_get_key (g_gpgme_ctx, id, &key, 1);
-    if (!GPG_IS_OK (gerr)) {
-        ret = g_strdup ("");
-    } else {
-        ret = extract_key_name (key);
-        gpgme_key_release (key);
-    }
-    
-    return ret;
-}
-
-static void 
-build_key_list (gpointer key, gpointer value, GList **names)
-{
-    sa_cache_t *it = (sa_cache_t*)value;
-    *names = g_list_prepend (*names, build_key_name (it->id));
-}
-
-/* Get list of all SeahorseKey's cached */
-GList* 
-seahorse_agent_cache_get_key_names ()
-{
-    GList *names = NULL;
-    g_assert (g_cache != NULL);
-    g_hash_table_foreach (g_cache, (GHFunc)build_key_list, &names);
-    return names;
-}
-
-/* -----------------------------------------------------------------------------
- * GENERIC CACHE FUNCTIONS
- */
-
-#define KEYRING_ATTR_TYPE "seahorse-key-type"
-#define KEYRING_ATTR_KEYID "openpgp-keyid"
-#define KEYRING_VAL_GPG "openpgp"
-
-static gboolean 
-only_internal_cache ()
-{
-    gboolean internal = TRUE;
-    
-    /* No cache, internal must still work though */
-    if (!seahorse_gconf_get_boolean (SETTING_CACHE))
-        internal = TRUE;
-    
-    else {
-        gchar *method = seahorse_gconf_get_string (SETTING_METHOD);
-        if (method && strcmp (method, METHOD_GNOME) == 0)
-            internal = FALSE;
-        g_free (method);
-    }
-    
-    return internal;
-}
-
-static const gchar*
-gkeyring_keyid (const gchar *fullid)
-{
-    size_t len = strlen(fullid);
-    return fullid + (len > 16 ? len - 16 : 0);
-}
-
-void
-seahorse_agent_cache_set (const gchar *id, const gchar *pass, gboolean lock)
-{
-    /* Store in our internal cache */
-    seahorse_agent_internal_set (id, pass, lock);
-
-    /* Store in gnome-keyring */
-    if (id && !only_internal_cache ()) {
-        
-        GnomeKeyringResult res;
-        GnomeKeyringAttributeList *attributes = NULL;
-        guint item_id;
-        gchar *desc = NULL, *name;
-
-        name = build_key_name (id);
-        desc = g_strdup_printf (_("PGP Key: %s"), name);
-        g_free (name);
-        
-        attributes = gnome_keyring_attribute_list_new ();
-        gnome_keyring_attribute_list_append_string (attributes, KEYRING_ATTR_TYPE, 
-                                                    KEYRING_VAL_GPG);
-        gnome_keyring_attribute_list_append_string (attributes, KEYRING_ATTR_KEYID, 
-                                                    gkeyring_keyid (id));
-        res = gnome_keyring_item_create_sync (NULL, GNOME_KEYRING_ITEM_GENERIC_SECRET, 
-                                              desc, attributes, pass, TRUE, &item_id);
-        gnome_keyring_attribute_list_free (attributes);
-        g_free (desc);
-        
-        if (res != GNOME_KEYRING_RESULT_OK)
-            g_warning ("Couldn't store password in keyring: (code %d)", res);
-    }
-}
-
-void
-seahorse_agent_cache_clear (const gchar *id)
-{
-    /* Clear from our internal cache */
-    seahorse_agent_internal_clear (id);
-    
-    /* Clear from gnome-keyring */
-    if (id && !only_internal_cache ()) {
-        
-        GnomeKeyringResult res;
-        GnomeKeyringAttributeList *attributes = NULL;
-        GList *found_items, *l;
-        
-        attributes = gnome_keyring_attribute_list_new ();
-        gnome_keyring_attribute_list_append_string (attributes, KEYRING_ATTR_KEYID, 
-                                                    gkeyring_keyid (id));
-        res = gnome_keyring_find_items_sync (GNOME_KEYRING_ITEM_GENERIC_SECRET,
-                                             attributes, &found_items);
-        gnome_keyring_attribute_list_free (attributes);
-        
-        if (res != GNOME_KEYRING_RESULT_OK) {
-            g_warning ("couldn't search keyring: (code %d)", res);
-            
-        } else {
-            for (l = found_items; l; l = g_list_next (l)) {
-                /* TODO: Can we use async here? */
-                res = gnome_keyring_item_delete_sync (NULL, 
-                                    ((GnomeKeyringFound*)(l->data))->item_id);
-                if (res != GNOME_KEYRING_RESULT_OK)
-                    g_warning ("Couldn't clear password from keyring: (code %d)", res);
-            }
-            
-            gnome_keyring_found_list_free (found_items);
-        }
-        
-    }
-}
-
-const gchar* 
-seahorse_agent_cache_get (const gchar *id)
-{
-    const gchar *ret = NULL;
-    
-    /* Always look in our own keyring first */
-    ret = seahorse_agent_internal_get (id);
-    
-    /* Clear from gnome-keyring */
-    if (!ret && id && !only_internal_cache ()) {
-        
-        GnomeKeyringResult res;
-        GnomeKeyringAttributeList *attributes = NULL;
-        GList *found_items;
-        GnomeKeyringFound *found;
-        
-        attributes = gnome_keyring_attribute_list_new ();
-        gnome_keyring_attribute_list_append_string (attributes, KEYRING_ATTR_KEYID, 
-                                                    gkeyring_keyid (id));
-        res = gnome_keyring_find_items_sync (GNOME_KEYRING_ITEM_GENERIC_SECRET,
-                                             attributes, &found_items);
-        gnome_keyring_attribute_list_free (attributes);
-        
-        if (res != GNOME_KEYRING_RESULT_OK) {
-            if (res != GNOME_KEYRING_RESULT_DENIED)
-                g_warning ("couldn't search keyring: (code %d)", res);
-            
-        } else {
-            
-            if (found_items && found_items->data) {
-                found = (GnomeKeyringFound*)found_items->data;
-                if (found->secret) {
-                    
-                    /* Store it temporarily in our loving hands */
-                    seahorse_agent_internal_set (NULL, found->secret, TRUE);
-                    ret = seahorse_agent_internal_get (NULL);
-                
-                }
-            }
-            
-            gnome_keyring_found_list_free (found_items);
-        }
-        
-    }
-    
-    return ret;
-}
-
-/* Check if a given id is in the cache, and lock if requested */
-gboolean
-seahorse_agent_cache_has (const gchar *id, gboolean lock)
-{
-    if (seahorse_agent_internal_has (id, lock))
-        return TRUE;
-    
-    /* Retrieve from keyring and lock in local */
-    if (id && !only_internal_cache ()) {
-        
-        const gchar *pass = seahorse_agent_cache_get (id);
-        if (!pass)
-            return FALSE;
-        
-        /* Store it in our loving hands */
-        seahorse_agent_internal_set (id, pass, TRUE);
-        return TRUE;
-    }
-    
-    return FALSE;
-}
diff --git a/agent/seahorse-agent-cache.xml b/agent/seahorse-agent-cache.xml
deleted file mode 100644
index 3bb1cfc..0000000
--- a/agent/seahorse-agent-cache.xml
+++ b/dev/null
@@ -1,156 +0,0 @@
-<?xml version="1.0"?>
-<interface>
-  <requires lib="gtk+" version="2.16"/>
-  <!-- interface-naming-policy toplevel-contextual -->
-  <object class="GtkDialog" id="agent-cache">
-    <property name="visible">True</property>
-    <property name="title" translatable="yes">Cached Encryption Keys</property>
-    <property name="window_position">center</property>
-    <property name="default_width">380</property>
-    <property name="default_height">250</property>
-    <property name="type_hint">normal</property>
-    <property name="skip_taskbar_hint">True</property>
-    <property name="has_separator">False</property>
-    <child internal-child="vbox">
-      <object class="GtkVBox" id="dialog-vbox1">
-        <property name="visible">True</property>
-        <child>
-          <object class="GtkVBox" id="vbox1">
-            <property name="visible">True</property>
-            <property name="border_width">12</property>
-            <property name="spacing">12</property>
-            <child>
-              <object class="GtkScrolledWindow" id="scrolledwindow1">
-                <property name="visible">True</property>
-                <property name="can_focus">True</property>
-                <property name="hscrollbar_policy">automatic</property>
-                <property name="vscrollbar_policy">automatic</property>
-                <child>
-                  <object class="GtkTreeView" id="key_list">
-                    <property name="visible">True</property>
-                    <property name="can_focus">True</property>
-                    <property name="border_width">3</property>
-                  </object>
-                </child>
-              </object>
-              <packing>
-                <property name="position">0</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkVBox" id="vbox2">
-                <property name="visible">True</property>
-                <child>
-                  <object class="GtkLabel" id="insecure_label">
-                    <property name="can_focus">True</property>
-                    <property name="xalign">0</property>
-                    <property name="yalign">0</property>
-                    <property name="label" translatable="yes">&lt;b&gt;Warning&lt;/b&gt;: Your system is not configured to cache passphrases in secure memory.</property>
-                    <property name="use_markup">True</property>
-                    <property name="wrap">True</property>
-                    <property name="selectable">True</property>
-                  </object>
-                  <packing>
-                    <property name="position">0</property>
-                  </packing>
-                </child>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="pack_type">end</property>
-                <property name="position">1</property>
-              </packing>
-            </child>
-          </object>
-          <packing>
-            <property name="pack_type">end</property>
-            <property name="position">1</property>
-          </packing>
-        </child>
-        <child internal-child="action_area">
-          <object class="GtkHButtonBox" id="dialog-action_area1">
-            <property name="visible">True</property>
-            <property name="layout_style">end</property>
-            <child>
-              <object class="GtkButton" id="clear_button">
-                <property name="label">gtk-clear</property>
-                <property name="visible">True</property>
-                <property name="can_focus">True</property>
-                <property name="can_default">True</property>
-                <property name="receives_default">False</property>
-                <property name="use_stock">True</property>
-                <signal name="clicked" handler="clear_clicked"/>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="fill">False</property>
-                <property name="position">0</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkButton" id="close_button">
-                <property name="label">gtk-close</property>
-                <property name="visible">True</property>
-                <property name="can_focus">True</property>
-                <property name="has_focus">True</property>
-                <property name="can_default">True</property>
-                <property name="has_default">True</property>
-                <property name="receives_default">False</property>
-                <property name="use_stock">True</property>
-                <accelerator key="Escape" signal="clicked"/>
-                <signal name="clicked" handler="close_clicked"/>
-              </object>
-              <packing>
-                <property name="expand">False</property>
-                <property name="fill">False</property>
-                <property name="position">1</property>
-              </packing>
-            </child>
-          </object>
-          <packing>
-            <property name="expand">False</property>
-            <property name="pack_type">end</property>
-            <property name="position">0</property>
-          </packing>
-        </child>
-      </object>
-    </child>
-    <action-widgets>
-      <action-widget response="-5">clear_button</action-widget>
-      <action-widget response="-5">close_button</action-widget>
-    </action-widgets>
-  </object>
-  <object class="GtkMenu" id="context-menu">
-    <child>
-      <object class="GtkImageMenuItem" id="clear_cache">
-        <property name="label">_Clear Cache</property>
-        <property name="visible">True</property>
-        <property name="use_underline">True</property>
-        <property name="use_stock">True</property>
-        <signal name="activate" handler="on_clear_cache_activate"/>
-      </object>
-    </child>
-    <child>
-      <object class="GtkMenuItem" id="show_window">
-        <property name="visible">True</property>
-        <property name="label" translatable="yes">_Show Window</property>
-        <property name="use_underline">True</property>
-        <signal name="activate" handler="on_show_window_activate"/>
-      </object>
-    </child>
-    <child>
-      <object class="GtkSeparatorMenuItem" id="separator1">
-        <property name="visible">True</property>
-      </object>
-    </child>
-    <child>
-      <object class="GtkImageMenuItem" id="cache_settings">
-        <property name="label">Cache _Preferences</property>
-        <property name="visible">True</property>
-        <property name="use_underline">True</property>
-        <property name="use_stock">True</property>
-        <signal name="activate" handler="on_settings_activate"/>
-      </object>
-    </child>
-  </object>
-</interface>
diff --git a/agent/seahorse-agent-io.c b/agent/seahorse-agent-io.c
deleted file mode 100644
index 6fd4609..0000000
--- a/agent/seahorse-agent-io.c
+++ b/dev/null
@@ -1,828 +0,0 @@
-/*
- * Seahorse
- *
- * Copyright (C) 2004-2005 Stefan Walter
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the
- * Free Software Foundation, Inc.,
- * 59 Temple Place, Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-#include <sys/param.h>
-#include <sys/socket.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/un.h>
-
-#include <stddef.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <err.h>
-#include <errno.h>
-#include <ctype.h>
-
-#include "seahorse-agent.h"
-
-/* Set from seahorse-agent-main.c */
-gboolean seahorse_agent_any_display = FALSE;
-
-/* Override the DEBUG_REFRESH_ENABLE switch here */
-/* #define DEBUG_AGENTIO_ENABLE 0 */
-
-#ifndef DEBUG_AGENTIO_ENABLE
-#if _DEBUG
-#define DEBUG_AGENTIO_ENABLE 1
-#else
-#define DEBUG_AGENTIO_ENABLE 0
-#endif
-#endif
-
-#if DEBUG_AGENTIO_ENABLE
-#define DEBUG_AGENTIO(x)    g_printerr x
-#else
-#define DEBUG_AGENTIO(x)
-#endif
-
-/*
- * Handles the server and open sockets. Parses received commands 
- * and sends back responses when instructed to. Note that we don't
- * use a seperate thread. Every uses glib event sources. This allows
- * a clean and reliable implementation.
- */
-
-static GList *g_connections = NULL;     /* All open connections */
-
-static gint g_socket = -1;              /* Socket we're listening on */
-static GIOChannel *g_iochannel = NULL;  /* IO channel for above */
-static gint g_iochannel_tag = 0;        /* Event source tag for above */
-static char *g_socket_name;             /* Name of socket we're listening on */
-
-struct _SeahorseAgentConn {
-    gint stag;                  /* glib source tag */
-    gboolean input;             /* Whether in input mode or not */
-    GIOChannel *iochannel;      /* Io channel for connection */
-    gboolean terminal_ok;        /* Whether this is from the current display */
-};
-
-/* -----------------------------------------------------------------------------
- *  DEFINES and DEFAULTS
- */
-
-#define SOCKET_DIR  "seahorse-XXXXXX"
-#define SOCKET_FILE "/S.gpg-agent"
-
-/* Commands */
-#define ASS_ID      "AGENT_ID"
-#define ASS_NOP     "NOP"
-#define ASS_BYE     "BYE"
-#define ASS_RESET   "RESET"
-#define ASS_OPTION  "OPTION"
-#define ASS_GETPASS "GET_PASSPHRASE"
-#define ASS_CLRPASS "CLEAR_PASSPHRASE"
-#define ASS_GETINFO "GETINFO"
-
-#define ASS_OPT_DISPLAY "display="
-
-/* Options */
-#define ASS_FLAG_DATA   "data"
-#define ASS_FLAG_CHECK  "check"
-#define ASS_FLAG_REPEAT "repeat"
-
-/* Responses */
-#define ASS_OK      "OK "
-#define ASS_ERR     "ERR "
-#define ASS_DATA    "D "
-#define NL          "\n"
-
-/* -------------------------------------------------------------------------- */
-
-static int
-set_cloexec_flag (int fd)
-{
-    int oldflags;
-   
-    oldflags = fcntl (fd, F_GETFD, 0);
-    /* If reading the flags failed, return error indication now.*/
-    if (oldflags < 0)
-    return oldflags;
-    /* Set just the flag we want to set. */
-    oldflags |= FD_CLOEXEC;
-
-    /* Store modified flag word in the descriptor. */
-    return fcntl (fd, F_SETFD, oldflags);
-}
-
-
-/* Create the socket and fill in sockname with its path */
-int
-seahorse_agent_io_socket ()
-{
-    struct sockaddr_un addr;
-    gchar *t;
-    int len;
-    
-    g_assert (g_socket == -1);
-
-    /* We build put the socket in a directory called /tmp/seahorse-XXXXXX */
-    g_free (g_socket_name);
-    g_socket_name = g_build_filename (g_get_tmp_dir (), SOCKET_DIR, NULL);
-
-    /* Make the appropriate directory */
-    if (!mkdtemp (g_socket_name)) {
-        g_critical ("can't create directory: %s: %s", g_socket_name,
-                    strerror (errno));
-        return -1;
-    }
-
-    /* Make sure nobody else can use the socket */
-    if (chmod(g_socket_name, 0700) == -1)
-        g_warning ("couldn't set permissions on directory: %s", strerror (errno));
-
-    /* Build the socket name */
-    t = g_socket_name;
-    g_socket_name = g_strdup_printf ("%s%s", g_socket_name, SOCKET_FILE);
-    g_free (t);
-
-    memset (&addr, 0, sizeof (addr));
-    addr.sun_family = AF_UNIX;
-    strncpy (addr.sun_path, g_socket_name, KL (addr.sun_path));
-    addr.sun_path[KL (addr.sun_path)] = 0;
-
-    len = offsetof (struct sockaddr_un, sun_path) + strlen (addr.sun_path) + 1;
-
-    /* Now make the appropriate socket */
-    g_socket = socket (AF_UNIX, SOCK_STREAM, 0);
-    if (g_socket == -1) {
-        g_critical ("can't create socket: %s", strerror (errno));
-        return -1;
-    }
-
-    if (set_cloexec_flag (g_socket) < 0)
-        g_warning ("can't set close-on-exec flag: %s", strerror (errno));
-
-    /* Bind it to the address */
-    if (bind (g_socket, (struct sockaddr *) &addr, len) == -1) {
-        g_critical ("couldn't bind to socket: %s: %s", addr.sun_path,
-                    strerror (errno));
-        return -1;
-    }
-
-    /* Make sure nobody else can use the socket */
-    if (chmod(g_socket_name, 0600) == -1)
-        g_warning ("couldn't set permissions on socket: %s", strerror (errno));
-
-    return 0;
-}
-
-const gchar*
-seahorse_agent_io_get_socket ()
-{
-    return g_socket_name;
-}
-
-/* Disconnect the connection */
-static void
-disconnect (SeahorseAgentConn *cn)
-{
-    /* The watch tag */
-    if (cn->stag) {
-        g_source_remove (cn->stag);
-        cn->stag = 0;
-
-        if (cn->iochannel)
-            g_io_channel_shutdown (cn->iochannel, TRUE, NULL);
-    }
-}        
-
-/* Free the given connection structure */
-static void
-free_conn (SeahorseAgentConn *cn)
-{
-    if (cn->iochannel) {
-        disconnect (cn);
-
-        g_io_channel_unref (cn->iochannel);
-        cn->iochannel = NULL;
-    }
-
-    g_connections = g_list_remove (g_connections, cn);
-    g_slice_free (SeahorseAgentConn, cn);
-}
-
-/* Is the argument a assuan null parameter? */
-static gboolean
-is_null_argument (gchar *arg)
-{
-    return (strcmp (arg, "X") == 0);
-}
-
-static const gchar HEX_CHARS[] = "0123456789ABCDEF";
-
-/* Decode an assuan parameter */
-static void
-decode_assuan_arg (gchar *arg)
-{
-    gchar *t;
-    gint len;
-
-    for (len = strlen (arg); len > 0; arg++, len--) {
-        switch (*arg) {
-            /* + becomes a space */
-        case '+':
-            *arg = ' ';
-            break;
-
-            /* hex encoded as in URIs */
-        case '%':
-            *arg = '?';
-            t = strchr (HEX_CHARS, arg[1]);
-            if (t != NULL) {
-                *arg = ((t - HEX_CHARS) & 0xf) << 4;
-                t = strchr (HEX_CHARS, arg[2]);
-                if (t != NULL)
-                    *arg |= (t - HEX_CHARS) & 0xf;
-            }
-            len -= 2;
-            if (len < 1)        /* last char, null terminate */
-                arg[1] = 0;
-            else                /* collapse rest */
-                memmove (arg + 1, arg + 3, len);
-            break;
-        };
-    }
-}
-
-/* Parse an assuan argument that we recognize */
-static guint32
-parse_assuan_flag (gchar *flag)
-{
-    g_assert (flag);
-    if (g_str_equal (flag, ASS_FLAG_DATA))
-        return SEAHORSE_AGENT_PASS_AS_DATA;
-    else if (g_str_has_prefix (flag, ASS_FLAG_REPEAT)) {
-        gint count = 1;
-
-        flag += strlen(ASS_FLAG_REPEAT);
-        if (*flag == '=') {
-            count = atoi (++flag);
-            if (!(count == 0 || count == 1))
-                g_warning ("--repeat=%d treated as --repeat=1", count);
-        }
-
-        if (count)
-            return SEAHORSE_AGENT_REPEAT;
-    }
-    return 0;
-}
-
-/* Split a line into each of it's arguments. This modifies line */
-static void
-split_arguments (gchar *line, guint32 *flags, ...)
-{
-    gchar **cur;
-    gchar *flag;
-    va_list ap;
-
-    va_start (ap, flags);
-
-    /* Initial white space */
-    while (*line && isspace (*line))
-        line++;
-    
-    /* The flags */
-    if (flags) {
-        *flags = 0;
-        
-        while (*line) {
-            /* Options start with a double dash */
-            if(!(line[0] == '-' && line[1] == '-'))
-                break;
-            line +=2;
-            flag = line;
-        
-            /* All non-whitespace */
-            while (*line && !isspace (*line))
-                line++;
-
-            /* Skip and null any whitespace */
-            while (*line && isspace (*line)) {
-                *line = 0;
-                line++;
-            }
-        
-            *flags |= parse_assuan_flag (flag);
-        }
-    }
-    
-    /* The arguments */
-    while ((cur = va_arg (ap, gchar **)) != NULL) {
-        if (*line) {
-            *cur = line;
-
-            /* All non-whitespace */
-            while (*line && !isspace (*line))
-                line++;
-
-            /* Skip and null any whitespace */
-            while (*line && isspace (*line)) {
-                *line = 0;
-                line++;
-            }
-            
-            decode_assuan_arg (*cur);
-        } else {
-            *cur = NULL;
-        }
-    }
-
-    va_end (ap);
-}
-
-static guint
-x11_display_dot_offset (const gchar *d) 
-{
-    const gchar *p;
-    guint l = strlen (d);
-    
-    for (p = d + l; *p != '.'; --p) {
-        if (p <= d)
-            break;
-        if (*p == ':')
-            break;
-    }
-    if (*p == '.')
-        l = p - d;
-
-    return l;
-}
-
-/*
- * Displays are of the form: hostname:displaynumber.screennumber, where
- * hostname can be empty (to indicate a local connection).
- * Two displays are equivalent if their hostnames and displaynumbers match.
- */
-static gboolean
-x11_displays_eq (const gchar *d1, const gchar *d2) 
-{
-    guint l1, l2;
-
-    if (seahorse_agent_any_display)
-        return TRUE;
-
-	l1 = x11_display_dot_offset (d1);
-    l2 = x11_display_dot_offset (d2);
-    return (g_ascii_strncasecmp (d1, d2, l1 > l2 ? l1 : l2) == 0);
-}
-
-/* Does command have option? */
-static gboolean
-command_has_option (SeahorseAgentConn *cn, gchar * command, gchar * option)
-{
-    gboolean has_option = FALSE;
-
-    if (!strcmp (command, ASS_GETPASS)) {
-        has_option = (!strcmp (option, ASS_FLAG_DATA) ||
-                      !strcmp (option, ASS_FLAG_REPEAT));
-    }
-    /* else if (other commands) */
-
-    if (has_option)
-        seahorse_agent_io_reply (cn, TRUE, NULL);
-
-    return has_option;
-}
-
-/* Process a GETINFO request */
-static void
-ass_getinfo (SeahorseAgentConn *cn, gchar * request)
-{
-    gchar *args;
-    gboolean implemented = FALSE;
-
-    args = strchr (request, ' ');
-    if (args) {
-        *args = 0;
-        args++;
-        while (isspace (*args))
-            args++;
-    }
-
-    if (!strcmp (request, "cmd_has_option")) {
-        gchar *command = args;
-        gchar *option;
-
-        if (!command || !*command) {
-            seahorse_agent_io_reply (cn, FALSE, "105 parameter error");
-            return;
-        }
-
-        option = strchr(args, ' ');
-
-        if (option) {
-            *option = 0;
-            option++;
-            while (isspace (*option))
-                option++;
-        } else {
-            seahorse_agent_io_reply (cn, FALSE, "105 parameter error");
-            return;
-        }
-
-        implemented = command_has_option(cn, command, option);
-    }
-    /* else if (other info request) */
-
-    if (!implemented)
-        seahorse_agent_io_reply (cn, FALSE, "100 not implemented");
-}
-
-/* Process a request line from client */
-static void
-process_line (SeahorseAgentConn *cn, gchar *string)
-{
-    gchar *args;
-
-    DEBUG_AGENTIO (("[agent-io] got line:\n%s", string));
-
-    g_strstrip (string);
-
-    if (strlen (string) == 0)
-        return;                 /* don't worry about empty lines */
-
-    /* Split the command off from the args */
-    args = strchr (string, ' ');
-    if (args) {
-        *args = 0;
-        args++;
-    } else {
-        /* Pointer to the end, empty string */
-        args = string + strlen (string);
-    }
-
-    /* We received a line, hold on until response is sent */
-    cn->input = FALSE;
-
-    if (strcasecmp (string, ASS_OPTION) == 0) {
-        gchar *option;
-        
-        split_arguments (args, NULL, &option, NULL);
-        
-        if (!option) {
-            seahorse_agent_io_reply (cn, FALSE, "105 parameter error");
-            g_warning ("received invalid option argument");
-            return;
-        }
-            
-        /* 
-         * If the option is a display option we make sure it's 
-         * the same as our display. Otherwise we don't answer.
-         */
-        if (g_ascii_strncasecmp (option, ASS_OPT_DISPLAY, KL (ASS_OPT_DISPLAY)) == 0) {
-            option += KL (ASS_OPT_DISPLAY);
-
-            if (x11_displays_eq (option, g_getenv ("DISPLAY"))) {
-                cn->terminal_ok = TRUE;
-            } else {
-                g_warning ("received request different display: %s", option);
-                seahorse_agent_io_reply (cn, FALSE, "105 parameter conflict");
-                return;
-            }
-        }
-        
-        /* We don't do anything with the other options right now */
-        seahorse_agent_io_reply (cn, TRUE, NULL);
-    }
-
-    else if (strcasecmp (string, ASS_GETPASS) == 0) {
-        gchar *id;
-        gchar *errmsg;
-        gchar *prompt;
-        gchar *description;
-        guint32 flags;
-
-        /* We don't answer this unless it's from the right terminal */
-        if (!cn->terminal_ok) {
-            seahorse_agent_io_reply (cn, FALSE, "113 Server Resource Problem");
-            g_warning ("received passphrase request from wrong terminal");
-            return;
-        }
-                
-        split_arguments (args, &flags, &id, &errmsg, &prompt, &description, NULL);
-
-        if (!id || !errmsg || !prompt || !description) {
-            seahorse_agent_io_reply (cn, FALSE, "105 parameter error");
-            g_warning ("received invalid passphrase request");
-            return;
-        }
-
-        if (is_null_argument (id))
-            id = NULL;
-        if (is_null_argument (errmsg))
-            errmsg = NULL;
-        if (is_null_argument (prompt))
-            prompt = NULL;
-        if (is_null_argument (description))
-            description = NULL;
-
-        seahorse_agent_actions_getpass (cn, flags, id, errmsg, prompt, description);
-    }
-
-    else if (strcasecmp (string, ASS_CLRPASS) == 0) {
-        gchar *id;
-
-        /* We don't answer this unless it's from the right terminal */
-        if (!cn->terminal_ok) {
-            seahorse_agent_io_reply (cn, FALSE, "113 Server Resource Problem");
-            g_warning ("received passphrase request from wrong terminal");
-            return;
-        }
-
-        split_arguments (args, NULL, &id, NULL);
-
-        if (!id) {
-            seahorse_agent_io_reply (cn, FALSE, "105 parameter error");
-            g_warning ("received invalid clear pass request: %s", string);
-        }
-
-        seahorse_agent_actions_clrpass (cn, id);
-    }
-
-    else if (strcasecmp (string, ASS_GETINFO) == 0) {
-        ass_getinfo (cn, args);
-    }
-
-    else if (strcasecmp (string, ASS_NOP) == 0) {
-        seahorse_agent_io_reply (cn, TRUE, NULL);
-    }
-
-    else if (strcasecmp (string, ASS_BYE) == 0) {
-        seahorse_agent_io_reply (cn, TRUE, "closing connection");
-        disconnect (cn);
-    }
-
-    else if (strcasecmp (string, ASS_RESET) == 0) {
-        /* We keep no state :) */
-        seahorse_agent_io_reply (cn, TRUE, NULL);
-    }
-
-    else if (strcasecmp (string, ASS_ID) == 0) {
-        seahorse_agent_io_reply (cn, TRUE, "seahorse-agent");
-    }
-
-    else {
-        g_warning ("unrecognized command: %s", string);
-        seahorse_agent_io_reply (cn, FALSE, "103 unknown command");
-    }
-}
-
-/* Callback for data coming from client */
-static gboolean
-io_handler (GIOChannel *source, GIOCondition condition, gpointer data)
-{
-    SeahorseAgentConn *cn = (SeahorseAgentConn *) data;
-    gchar *string;
-    gsize length;
-    GError *err = NULL;
-    gboolean ret = TRUE;
-
-    if (condition & G_IO_IN) {
-        /* Read 1 line from the io channel, including newline character */
-        g_io_channel_read_line (source, &string, &length, NULL, &err);
-
-        if (err != NULL) {
-            g_critical ("couldn't read from socket: %s", err->message);
-            g_clear_error (&err);
-            free_conn (cn);
-            cn = NULL;
-            ret = FALSE;
-        }
-
-        else if (length > 0) {
-            /* Send it off for processing */
-            process_line (cn, string);
-        }
-
-        if (string)
-            g_free (string);
-    }
-
-    if (cn && condition & G_IO_HUP) {
-        free_conn (cn);
-        ret = FALSE;            /* removes watch */
-    }
-
-    return ret;
-}
-
-/* Double check that a connection hasn't gone away */
-static gboolean
-is_valid_conn (SeahorseAgentConn *cn)
-{
-    return cn && cn->iochannel && 
-           g_list_index (g_connections, cn) != -1;
-}
-
-/* Write all passed data to socket */
-static int
-write_raw_data (int fd, const gchar *data, int len)
-{
-    int r, x = 0;
-
-    /* 
-     * Guarantee that all data is written. We don't want to go
-     * through g_io_channel_xxx functions because they might cache
-     * their data. Passwords and the like shouldn't be cached anywhere
-     * but the secure memory.
-     */
-
-    if (len == -1)
-        len = strlen (data);
-
-    while (len > 0) {
-        r = write (fd, data, len);
-        if (r == -1) {
-            if (errno != EAGAIN && errno != EINTR) {
-                if (errno != EPIPE)
-                    g_critical ("couldn't write data to socket: %s", strerror (errno));
-                return -1;
-            }
-        }
-
-        else {
-            data += r;
-            len -= r;
-            x += r;
-        }
-    }
-
-    return x;
-}
-
-/* Called when seahorse-actions has a response to send back */
-void
-seahorse_agent_io_reply (SeahorseAgentConn *cn, gboolean ok, const gchar *response)
-{
-    int fd;
-
-    /* The connection could have closed in the meantime */
-    if (!is_valid_conn (cn))
-        return;
-
-    DEBUG_AGENTIO (("[agent-io] send line:\n%s%s\n", ok ? ASS_OK : ASS_ERR, response ? response : ""));
-
-    fd = g_io_channel_unix_get_fd (cn->iochannel);
-
-    if (write_raw_data (fd, ok ? ASS_OK : ASS_ERR, ok ? KL (ASS_OK) : KL (ASS_ERR))
-        == -1 || (response && write_raw_data (fd, response, -1)) == -1
-        || write_raw_data (fd, NL, KL (NL)) == -1) {
-        /* error message already printed */
-        disconnect (cn);
-    }
-
-    /* After sending back a response we're ready for more */
-    cn->input = TRUE;
-    return;
-}
-
-void
-seahorse_agent_io_data (SeahorseAgentConn *cn, const gchar *data)
-{
-    int fd;
-
-    /* The connection could have closed in the meantime */
-    if (!is_valid_conn (cn))
-        return;
-
-    DEBUG_AGENTIO (("[agent-io] send data:\n%s%s\n", ASS_DATA, data));
-
-    fd = g_io_channel_unix_get_fd (cn->iochannel);
-
-    if (write_raw_data (fd, ASS_DATA, KL (ASS_DATA)) == -1 ||
-        write_raw_data (fd, data, -1) == -1 ||
-	write_raw_data (fd, NL, KL (NL)) == -1) {
-        /* error message already printed */
-        disconnect (cn);
-    }
-
-    return;
-}
-
-/* Callback for new incoming connections */
-static gboolean
-connect_handler (GIOChannel *source, GIOCondition cond, gpointer data)
-{
-    SeahorseAgentConn *cn;
-    int fd;
-
-    g_return_val_if_fail (source, FALSE);
-    g_return_val_if_fail (cond == G_IO_IN, FALSE);
-
-    fd = accept (g_io_channel_unix_get_fd (source), NULL, NULL);
-    if (fd < 0) {
-        if (errno != EINTR && errno != EAGAIN)
-            g_critical ("couldn't accept connection: %s", strerror (errno));
-        return TRUE;            /* don't stop listening */
-    }
-
-    cn = g_slice_new0 (SeahorseAgentConn);
-
-    g_connections = g_list_append (g_connections, cn);
-
-    /* Setup io channel for new socket */
-    cn->iochannel = g_io_channel_unix_new (fd);
-    g_io_channel_set_close_on_unref (cn->iochannel, TRUE);
-    g_io_channel_set_encoding (cn->iochannel, NULL, NULL);
-    cn->stag = g_io_add_watch (cn->iochannel, G_IO_IN | G_IO_HUP, io_handler, cn);
-
-    /* 
-     * Initial response on the connection. This also enables
-     * listening on the connection
-     */
-    seahorse_agent_io_reply (cn, TRUE, "your orders please");
-
-    return TRUE;
-}
-
-/* Initialize the connection system */
-int
-seahorse_agent_io_init ()
-{
-    g_assert (g_socket != -1);
-    g_assert (g_iochannel == NULL);
-    g_assert (g_iochannel_tag == 0);
-
-    /* Listen for connections */
-    if (listen (g_socket, 5) == -1) {
-        g_critical ("couldn't listen for connections on socket: %s",
-                    strerror (errno));
-        return -1;
-    }
-
-    /* Watch for connections on the socket */
-    g_iochannel = g_io_channel_unix_new (g_socket);
-    g_io_channel_set_close_on_unref (g_iochannel, TRUE);
-    g_iochannel_tag = g_io_add_watch (g_iochannel, G_IO_IN, connect_handler, NULL);
-
-    return 0;
-}
-
-/* Callback for freeing all connections */
-static void
-free_connections (gpointer data, gpointer user_data)
-{
-    free_conn ((SeahorseAgentConn *) data);
-}
-
-/* Close all connections, free memory etc... */
-void
-seahorse_agent_io_uninit ()
-{
-    if (g_connections) {
-        g_list_foreach (g_connections, free_connections, NULL);
-        g_list_free (g_connections);
-        g_connections = NULL;
-    }
-
-    if (g_socket) {
-        GError *err = NULL;
-        gchar *t;
-
-        g_source_remove (g_iochannel_tag);
-        g_iochannel_tag = 0;
-        g_io_channel_shutdown (g_iochannel, FALSE, &err);
-        g_io_channel_unref (g_iochannel);
-        g_iochannel = NULL;
-        g_socket = -1;
-
-        g_clear_error (&err);
-
-        if (g_socket_name) {
-            /* Remove the socket */
-            unlink (g_socket_name);
-
-            /* Remove the directory */
-            t = strrchr (g_socket_name, '/');
-            if (t != NULL) {
-                *t = 0;
-                rmdir (g_socket_name);
-            }
-
-            g_free (g_socket_name);
-            g_socket_name = NULL;
-        }
-    }    
-}
diff --git a/agent/seahorse-agent-main.c b/agent/seahorse-agent-main.c
deleted file mode 100644
index 78e24d8..0000000
--- a/agent/seahorse-agent-main.c
+++ b/dev/null
@@ -1,287 +0,0 @@
-/*
- * Seahorse
- *
- * Copyright (C) 2006 Stefan Walter
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the
- * Free Software Foundation, Inc.,
- * 59 Temple Place, Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-#include "config.h"
-
-#include <sys/types.h>
-#include <sys/signal.h>
-
-#include <stddef.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <err.h>
-#include <unistd.h>
-#include <syslog.h>
-#include <fcntl.h>
-#include <string.h>
-#include <errno.h>
-  
-#include <glib/gi18n.h>
-
-#include "seahorse-gtkstock.h"
-#include "seahorse-gconf.h"
-#include "seahorse-agent.h"
-#include "seahorse-unix-signal.h"
-#include "seahorse-secure-memory.h"
-
-static gboolean display_vars_dummy = TRUE;
-static gboolean agent_no_daemonize = FALSE;
-static gboolean agent_running = FALSE;
-static gboolean agent_quit = FALSE;
-static gchar **agent_exec_args = NULL;
-
-static const GOptionEntry options[] = {
-    { "no-daemonize", 'd', 0, G_OPTION_ARG_NONE, &agent_no_daemonize, 
-        N_("Do not daemonize seahorse-agent"), NULL },
-
-    /* TRANSLATORS: An example of a 'C type shell' is 'csh' often used by *BSD instead of bash */
-    { "cshell", 'c', 0, G_OPTION_ARG_NONE, &seahorse_agent_cshell, 
-        N_("Print variables in for a C type shell"), NULL },
-
-    /* This is the default but is kept here for backward compatibility */
-    { "variables", 'v', 0, G_OPTION_ARG_NONE, &display_vars_dummy, 
-        N_("Display environment variables (the default)"), NULL },
-
-    { "execute", 'x', 0, G_OPTION_ARG_NONE, &seahorse_agent_execvars, 
-        N_("Execute other arguments on the command line"), NULL },
-      
-    /* TRANSLATORS: A 'display' is a an X display */
-    { "any-display", 'A', 0, G_OPTION_ARG_NONE, &seahorse_agent_any_display, 
-        N_("Allow GPG agent request from any display"), NULL },
-      
-    { G_OPTION_REMAINING, 0, 0, G_OPTION_ARG_STRING_ARRAY, &agent_exec_args, 
-        NULL, N_("command...") },
-
-    { NULL }
-};
-
-static int
-set_cloexec_flag (int fd)
-{
-    int oldflags;
-    
-    oldflags = fcntl (fd, F_GETFD, 0);
-    /* If reading the flags failed, return error indication now.*/
-    if (oldflags < 0)
-    return oldflags;
-    /* Set just the flag we want to set. */
-    oldflags |= FD_CLOEXEC;
-
-    /* Store modified flag word in the descriptor. */
-    return fcntl (fd, F_SETFD, oldflags);
-}
-
-static void
-daemonize (gchar **exec)
-{
-    /* 
-     * We can't use the normal daemon call, because we have
-     * special things to do in the parent after forking 
-     */
-
-    pid_t pid;
-    int i, fd;
-
-    if (agent_no_daemonize) {
-        pid = getpid ();
-
-    } else {
-        switch ((pid = fork ())) {
-        case -1:
-            err (1, _("couldn't fork process"));
-            break;
-
-        /* The child */
-        case 0:
-            if (setsid () == -1)
-                err (1, _("couldn't create new process group"));
-
-            /* Close std descriptors */
-            for (i = 0; i <= 2; i++)
-                close (i);
-            
-            /* Open stdin, stdout and stderr. GPGME doesn't work without this */
-            fd = open ("/dev/null", O_RDONLY, 0666);
-            if (set_cloexec_flag (fd) < 0)
-                g_warning ("can't set close-on-exec flag: %s", strerror (errno));
-                
-            fd = open ("/dev/null", O_WRONLY, 0666);
-            if (set_cloexec_flag (fd) < 0)
-                g_warning ("can't set close-on-exec flag: %s", strerror (errno));
-                
-            fd = open ("/dev/null", O_WRONLY, 0666);
-            if (set_cloexec_flag (fd) < 0)
-                g_warning ("can't set close-on-exec flag: %s", strerror (errno));
-            
-            chdir ("/tmp");
-            return; /* Child process returns */
-        };
-    }
-
-    /* The parent process or not daemonizing ... */
-
-    /* Let the agent do it's thing */
-    seahorse_agent_postfork (pid);
-    
-    if (agent_no_daemonize) {
-
-        /* We can't overlay our process with the exec one if not daemonizing */
-        if (exec && exec[0])
-            g_warning ("cannot execute process when not daemonizing: %s", exec[0]);    
-
-    } else {
-
-        /* If we were asked to exec another program, do that here */
-        if (!exec || !exec[0])
-            exit (0);
-
-        execvp (exec[0], (char**)exec);
-	    g_critical ("couldn't exec %s: %s\n", exec[0], g_strerror (errno));
-	    exit (1);
-
-    }
-}
-
-static void
-unix_signal (int signal)
-{
-    agent_quit = TRUE;
-    if (agent_running)
-        gtk_main_quit ();
-}
-
-static void
-log_handler (const gchar *log_domain, GLogLevelFlags log_level, 
-             const gchar *message, gpointer user_data)
-{
-    int level;
-
-    /* Note that crit and err are the other way around in syslog */
-        
-    switch (G_LOG_LEVEL_MASK & log_level) {
-    case G_LOG_LEVEL_ERROR:
-        level = LOG_CRIT;
-        break;
-    case G_LOG_LEVEL_CRITICAL:
-        level = LOG_ERR;
-        break;
-    case G_LOG_LEVEL_WARNING:
-        level = LOG_WARNING;
-        break;
-    case G_LOG_LEVEL_MESSAGE:
-        level = LOG_NOTICE;
-        break;
-    case G_LOG_LEVEL_INFO:
-        level = LOG_INFO;
-        break;
-    case G_LOG_LEVEL_DEBUG:
-        level = LOG_DEBUG;
-        break;
-    default:
-        level = LOG_ERR;
-        break;
-    }
-    
-    /* Log to syslog first */
-    if (log_domain)
-        syslog (level, "%s: %s", log_domain, message);
-    else
-        syslog (level, "%s", message);
- 
-    /* And then to default handler for aborting and stuff like that */
-    g_log_default_handler (log_domain, log_level, message, user_data); 
-}
-
-static void
-prepare_logging ()
-{
-    GLogLevelFlags flags = G_LOG_FLAG_FATAL | G_LOG_LEVEL_ERROR | 
-                G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING | 
-                G_LOG_LEVEL_MESSAGE | G_LOG_LEVEL_INFO;
-                
-    openlog ("seahorse-agent", LOG_PID, LOG_AUTH);
-    
-    g_log_set_handler (NULL, flags, log_handler, NULL);
-    g_log_set_handler ("Glib", flags, log_handler, NULL);
-    g_log_set_handler ("Gtk", flags, log_handler, NULL);
-    g_log_set_handler ("Gnome", flags, log_handler, NULL);
-}
-
-int main(int argc, char* argv[])
-{
-    GOptionContext *octx = NULL;
-
-    seahorse_secure_memory_init ();
-    
-    bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
-    bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
-    textdomain (GETTEXT_PACKAGE);
-    
-    octx = g_option_context_new ("");
-    g_option_context_add_main_entries (octx, options, GETTEXT_PACKAGE);
-
-    gtk_init_with_args (&argc, &argv, _("Encryption Key Agent (Seahorse)"), (GOptionEntry *) options, GETTEXT_PACKAGE, NULL);
-
-    seahorse_agent_prefork ();
-
-    if (seahorse_agent_execvars && 
-        (!agent_exec_args || !agent_exec_args[0]))
-        errx (2, _("no command specified to execute"));
-
-    /* 
-     * All functions after this point have to print messages 
-     * nicely and not just called exit() 
-     */
-    daemonize (seahorse_agent_execvars ? agent_exec_args : NULL);
-
-    atexit (seahorse_agent_exit);
-
-    g_strfreev (agent_exec_args);
-    agent_exec_args = NULL;
-
-    /* Handle some signals */
-    seahorse_unix_signal_register (SIGINT, unix_signal);
-    seahorse_unix_signal_register (SIGTERM, unix_signal);
-
-    /* Force gconf to reconnect after daemonizing */
-    if (!agent_no_daemonize)
-        seahorse_gconf_disconnect ();    
-    
-    /* We log to the syslog */
-    prepare_logging ();
-
-    /* Insert Icons into Stock */
-    seahorse_gtkstock_init ();
-    
-    if (!seahorse_agent_init ())
-        agent_quit = TRUE;
-    
-    /* Sometimes we've already gotten a quit signal */
-    if(!agent_quit) {
-        agent_running = TRUE;
-        gtk_main ();
-        g_message ("left gtk_main\n");
-    }
-
-    /* And now clean them all up */
-    seahorse_agent_uninit (NULL);
-
-    return 0;
-}
diff --git a/agent/seahorse-agent-prompt.c b/agent/seahorse-agent-prompt.c
deleted file mode 100644
index 273e1a9..0000000
--- a/agent/seahorse-agent-prompt.c
+++ b/dev/null
@@ -1,304 +0,0 @@
-/*
- * Seahorse
- *
- * Copyright (C) 2004 Stefan Walter
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the
- * Free Software Foundation, Inc.,
- * 59 Temple Place, Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-
-/* 
- * Much of the code is originally from pinentry-gtk2:
- * (C) by Albrecht Dre 2004 unter the terms of the GNU Lesser General
- * Public License.
- */
-
-#include "config.h"
-
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <glib/gi18n.h>
-
-#include "seahorse-agent.h"
-#include "seahorse-check-button-control.h"
-#include "seahorse-libdialogs.h"
-#include "seahorse-passphrase.h"
-
-#define HIG_SMALL      6        /* gnome hig small space in pixels */
-#define HIG_LARGE     12        /* gnome hig large space in pixels */
-
-/* Note: We only display one prompt at a time. */
-static GtkWidget *g_current_win = NULL;
-static GtkWidget *g_current_entry = NULL;
-
-/* Whether we currently have a prompt or not */
-gboolean
-seahorse_agent_prompt_have ()
-{
-    return g_current_win != NULL;
-}
-
-/* Destroy any current prompts */
-void
-seahorse_agent_prompt_cleanup ()
-{
-    if (g_current_win) {
-        gtk_widget_destroy (g_current_win);
-        g_current_win = NULL;
-        g_current_entry = NULL;
-    }
-}
-
-/* Convert passed text to utf-8 if not valid */
-static gchar *
-utf8_validate (const gchar *text)
-{
-    gchar *result;
-
-    if (!text)
-        return NULL;
-
-    if (g_utf8_validate (text, -1, NULL))
-        return g_strdup (text);
-
-    result = g_locale_to_utf8 (text, -1, NULL, NULL, NULL);
-    if (!result) {
-        gchar *p;
-
-        result = p = g_strdup (text);
-        while (!g_utf8_validate (p, -1, (const gchar **) &p))
-            *p = '?';
-    }
-    return result;
-}
-
-
-/* constrain_size - constrain size of the window the window should not
- * shrink beyond the requisition, and should not grow vertically */
-static void
-constrain_size (GtkWidget *win, GtkRequisition *req, gpointer data)
-{
-    static gint width, height;
-    GdkGeometry geo;
-
-    if (req->width == width && req->height == height)
-        return;
-
-    width = req->width;
-    height = req->height;
-    geo.min_width = width;
-    geo.max_width = 10000;      /* limit is arbitrary, INT_MAX breaks other things */
-    geo.min_height = geo.max_height = height;
-    gtk_window_set_geometry_hints (GTK_WINDOW (win), NULL, &geo,
-                                   GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE);
-}
-
-/* -----------------------------------------------------------------------------
- * PASSWORD PROMPT
- */
-
-/* Called to close the prompt */
-static void
-prompt_done_dialog (SeahorseAgentPassReq *pr, gboolean ok)
-{
-    const gchar *pass = NULL;
-    
-    g_return_if_fail (g_current_win);
-    gtk_widget_destroy (g_current_win);
-    g_current_win = NULL;
-
-    if (ok) {
-        pass = seahorse_agent_cache_get (pr->id);
-        g_return_if_fail (pass);
-    }
-
-    seahorse_agent_actions_donepass (pr, pass);
-}
-
-static void
-passphrase_response (GtkDialog *dialog, gint response, SeahorseAgentPassReq *pr)
-{
-    const char *s;
-
-    switch (response) {
-    case GTK_RESPONSE_ACCEPT:
-        s = seahorse_passphrase_prompt_get (dialog);
-        gtk_widget_hide (GTK_WIDGET (dialog));
-        seahorse_agent_cache_set (pr->id, s != NULL ? s : "", TRUE);
-        prompt_done_dialog (pr, TRUE);
-        break;
-    default:
-        prompt_done_dialog (pr, FALSE);
-        break;
-    };
-}
-
-void
-seahorse_agent_prompt_pass (SeahorseAgentPassReq *pr)
-{
-    GtkDialog *dialog;
-
-    g_return_if_fail (!seahorse_agent_prompt_have ());
-    
-    dialog =
-        seahorse_passphrase_prompt_show (NULL,
-                                         (pr->errmsg ?
-                                          pr->errmsg : pr->description),
-                                         pr->prompt, NULL,
-                                         pr->flags & SEAHORSE_AGENT_REPEAT);
-
-    g_signal_connect (dialog, "response", G_CALLBACK (passphrase_response), pr);
-    g_current_win = GTK_WIDGET (dialog);
-}
-
-
-/* -----------------------------------------------------------------------------
- * Authorize Prompt
- */
-
-/* Called when we want to close */
-static void
-auth_done_dialog (SeahorseAgentPassReq *pr, gboolean ok)
-{
-    g_return_if_fail (g_current_win);
-    gtk_widget_destroy (g_current_win);
-    g_current_win = NULL;
-
-    seahorse_agent_actions_doneauth (pr, ok);
-}
-
-/* Called when ok button pressed */
-static void
-auth_ok_button (GtkWidget *widget, gpointer data)
-{
-    SeahorseAgentPassReq *pr = (SeahorseAgentPassReq *) data;
-    auth_done_dialog (pr, TRUE);
-}
-
-/* Cancel button pressed */
-static void
-auth_cancel_button (GtkWidget * widget, gpointer data)
-{
-    SeahorseAgentPassReq *pr = (SeahorseAgentPassReq *) data;
-    auth_done_dialog (pr, FALSE);
-}
-
-/* Simulate a cancel when window closed */
-static int
-auth_delete_event (GtkWidget *widget, GdkEvent *event, gpointer data)
-{
-    auth_cancel_button (widget, data);
-    return TRUE;
-}
-
-/* Setup an authorize prompt */
-static GtkWidget *
-create_auth_window (SeahorseAgentPassReq *pr)
-{
-    GtkWidget *w;
-    GtkWidget *win;
-    GtkWidget *box;
-    GtkWidget *wvbox;
-    GtkWidget *chbox;
-    GtkWidget *bbox;
-    GtkAccelGroup *acc;
-    gchar *msg;
-
-    win = gtk_window_new (GTK_WINDOW_TOPLEVEL);
-    gtk_window_set_title (GTK_WINDOW (win), _("Authorize Passphrase Access"));
-    gtk_window_set_icon_name (GTK_WINDOW (win), GTK_STOCK_DIALOG_AUTHENTICATION);
-    acc = gtk_accel_group_new ();
-
-    g_signal_connect (G_OBJECT (win), "delete_event",
-                      G_CALLBACK (auth_delete_event), pr);
-
-    g_signal_connect (G_OBJECT (win), "size-request",
-                      G_CALLBACK (constrain_size), NULL);
-
-    gtk_window_add_accel_group (GTK_WINDOW (win), acc);
-
-    wvbox = gtk_vbox_new (FALSE, HIG_LARGE * 2);
-    gtk_container_add (GTK_CONTAINER (win), wvbox);
-    gtk_container_set_border_width (GTK_CONTAINER (wvbox), HIG_LARGE);
-
-    chbox = gtk_hbox_new (FALSE, HIG_LARGE);
-    gtk_box_pack_start (GTK_BOX (wvbox), chbox, FALSE, FALSE, 0);
-
-    w = gtk_image_new_from_stock (GTK_STOCK_DIALOG_AUTHENTICATION, GTK_ICON_SIZE_DIALOG);
-    gtk_misc_set_alignment (GTK_MISC (w), 0.0, 0.0);
-    gtk_box_pack_start (GTK_BOX (chbox), w, FALSE, FALSE, 0);
-
-    box = gtk_vbox_new (FALSE, HIG_SMALL);
-    gtk_box_pack_start (GTK_BOX (chbox), box, TRUE, TRUE, 0);
-
-    if (pr->description) {
-        msg = utf8_validate (pr->description);
-        w = gtk_label_new (msg);
-        g_free (msg);
-
-        gtk_misc_set_alignment (GTK_MISC (w), 0.0, 0.5);
-        gtk_label_set_line_wrap (GTK_LABEL (w), TRUE);
-        gtk_box_pack_start (GTK_BOX (box), w, TRUE, FALSE, 0);
-    }
-
-    w = gtk_label_new (_("The passphrase is cached in memory."));
-    gtk_misc_set_alignment (GTK_MISC (w), 0.0, 0.5);
-    gtk_label_set_line_wrap (GTK_LABEL (w), TRUE);
-    gtk_box_pack_start (GTK_BOX (box), w, TRUE, FALSE, 0);
-    
-    w = gtk_check_button_new_with_mnemonic (_("Always ask me before using a cached passphrase"));
-    seahorse_check_button_gconf_attach (GTK_CHECK_BUTTON (w), SETTING_AUTH);
-    
-    gtk_box_pack_start (GTK_BOX (box), w, TRUE, FALSE, 0);
-                                  
-    bbox = gtk_hbutton_box_new ();
-    gtk_button_box_set_layout (GTK_BUTTON_BOX (bbox), GTK_BUTTONBOX_END);
-    gtk_box_set_spacing (GTK_BOX (bbox), 6);
-    gtk_box_pack_start (GTK_BOX (wvbox), bbox, TRUE, FALSE, 0);
-
-    w = gtk_button_new_from_stock (GTK_STOCK_CANCEL);
-    gtk_container_add (GTK_CONTAINER (bbox), w);
-    g_signal_connect (G_OBJECT (w), "clicked", G_CALLBACK (auth_cancel_button), pr);
-
-    gtk_widget_set_can_default (w, TRUE);
-
-    w = gtk_button_new_from_stock (GTK_STOCK_OK);
-    gtk_button_set_label (GTK_BUTTON (w), _("_Authorize"));
-    gtk_button_set_use_underline (GTK_BUTTON (w), TRUE);
-    gtk_container_add (GTK_CONTAINER (bbox), w);
-
-    g_signal_connect (G_OBJECT (w), "clicked", G_CALLBACK (auth_ok_button), pr);
-    gtk_widget_set_can_default (w, TRUE);
-    gtk_widget_grab_default (w);
-
-    gtk_window_set_position (GTK_WINDOW (win), GTK_WIN_POS_CENTER);
-    gtk_window_set_keep_above(GTK_WINDOW (win), TRUE);
-    gtk_widget_show_all (win);
-    gdk_window_focus (gtk_widget_get_window (win), GDK_CURRENT_TIME);
-    return win;
-}
-
-/* Show an authorize prompt window */
-void
-seahorse_agent_prompt_auth (SeahorseAgentPassReq *pr)
-{
-    g_return_if_fail (!seahorse_agent_prompt_have ());
-    g_current_win = create_auth_window (pr);
-}
diff --git a/agent/seahorse-agent-status.c b/agent/seahorse-agent-status.c
deleted file mode 100644
index 02c9887..0000000
--- a/agent/seahorse-agent-status.c
+++ b/dev/null
@@ -1,349 +0,0 @@
-/*
- * Seahorse
- *
- * Copyright (C) 2004 Stefan Walter
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the
- * Free Software Foundation, Inc.,
- * 59 Temple Place, Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-#include <sys/types.h>
-#include <stdlib.h>
-
-#include <glib/gi18n.h>
-
-#include <gtk/gtk.h>
-
-#include "seahorse-agent.h"
-#include "seahorse-gtkstock.h"
-#include "seahorse-gconf.h"
-#include "seahorse-widget.h"
-#include "seahorse-util.h"
- 
-/* 
- * Implements tray icon, menu and status window. Tray icon ideas 
- * came from gaim
- */
-
-/* For the docklet icon */
-static GtkStatusIcon *g_docklet = NULL;
-
-/* For the popup window */
-static SeahorseWidget *g_window = NULL;
-
-/* gconf notify id for diaplying the cache */
-static guint g_notify_id = 0;   
-
-/* -----------------------------------------------------------------------------
- *  Popup Window
- */
-
-enum {
-    ICON_COLUMN,
-    UID_COLUMN,
-    N_COLUMNS
-};
-
-/* Called to close status window */
-G_MODULE_EXPORT void
-window_destroy ()
-{
-    if (g_window) {
-        seahorse_widget_destroy (g_window);
-        g_window = NULL;
-    }
-}
-
-/* When window close clicked we close window */
-G_MODULE_EXPORT static int
-delete_event (GtkWidget *widget, GdkEvent *event, gpointer data)
-{
-    window_destroy ();
-    return FALSE;
-}
-
-/* When close button clicked */
-G_MODULE_EXPORT static void
-close_clicked (GtkButton *button, SeahorseWidget *swidget)
-{
-    window_destroy ();
-}
-
-/* Clear button, clear cache and close */
-G_MODULE_EXPORT static void
-clear_clicked (GtkButton *button, SeahorseWidget *swidget)
-{
-    seahorse_agent_cache_clearall ();
-    window_destroy ();
-}
-
-/* Add a row to the tree for a given password */
-static void
-add_keys_to_store (GtkTreeStore *store, GList *names)
-{
-    GList *l;
-    GtkTreeIter iter;
-    
-    for (l = names; l; l = g_list_next (l)) {
-        
-        /* Add a new row to the model */
-        gtk_tree_store_append (store, &iter, NULL);
-        
-        gtk_tree_store_set (store, &iter, 
-                    UID_COLUMN, l->data,
-                    ICON_COLUMN, SEAHORSE_STOCK_SECRET,
-                    -1);
-        
-        g_free (l->data);
-    }
-    
-    g_list_free (names);
-}
-
-/* Called when the cache changes and window is open */
-static void
-window_update_keys ()
-{
-    GtkTreeViewColumn *column;
-    GtkCellRenderer  *renderer;
-    GtkTreeStore *store;
-    GtkTreeView *tree;
-    
-    g_return_if_fail (g_window != NULL);
-    tree = GTK_TREE_VIEW (seahorse_widget_get_widget (g_window, "key_list"));
-    g_return_if_fail (tree != NULL);
-
-    store = GTK_TREE_STORE (gtk_tree_view_get_model (tree));
-    if (!store) {
-        /* This is our first time so create a store */
-        store = gtk_tree_store_new (N_COLUMNS, G_TYPE_STRING, G_TYPE_STRING);
-        gtk_tree_view_set_model (tree, GTK_TREE_MODEL (store));
-        
-        /* Make the icon column */
-        renderer = gtk_cell_renderer_pixbuf_new ();
-        g_object_set (renderer, "stock-size", GTK_ICON_SIZE_LARGE_TOOLBAR, NULL);
-        column = gtk_tree_view_column_new_with_attributes ("", renderer, 
-                                                           "stock-id", ICON_COLUMN, NULL);
-        gtk_tree_view_column_set_resizable (column, FALSE);
-        gtk_tree_view_append_column (tree, column);
-
-        /* Make the uid column */
-        column = gtk_tree_view_column_new_with_attributes (_("Key Name"),
-                                                           gtk_cell_renderer_text_new (), 
-                                                           "text", UID_COLUMN, NULL);
-        gtk_tree_view_append_column (tree, column);
-    } else {
-        /* Clear the store we refill below */
-        gtk_tree_store_clear (store);
-    }
-    
-    /* The keys from the PGP cache */
-    add_keys_to_store (store, seahorse_agent_cache_get_key_names ());
-}
-
-/* Display the status window */
-static void
-window_show ()
-{
-    GtkWidget *w;
-    
-    if (g_window) {
-        w = GTK_WIDGET (seahorse_widget_get_widget (g_window, g_window->name));
-        gtk_window_present (GTK_WINDOW (w));
-        return;
-    }
-
-    g_window = seahorse_widget_new ("agent-cache", NULL);
-    w = GTK_WIDGET (seahorse_widget_get_widget (g_window, g_window->name));
-
-    g_signal_connect (G_OBJECT (w), "delete_event", G_CALLBACK (delete_event), NULL);
-
-    w = GTK_WIDGET (seahorse_widget_get_widget (g_window, "close_button"));
-    g_signal_connect (G_OBJECT (w), "clicked", G_CALLBACK (close_clicked), g_window);
-    
-    w = GTK_WIDGET (seahorse_widget_get_widget (g_window, "clear_button"));
-    g_signal_connect (G_OBJECT (w), "clicked", G_CALLBACK (clear_clicked), g_window);
-
-    window_update_keys ();
-}
-
-/* -----------------------------------------------------------------------------
- *  TRAY ICON
- */
-
-/* Menu item for clearing cache */
-static void
-on_clear_cache_activate (GtkWidget *item, gpointer data)
-{
-    clear_clicked (NULL, NULL);
-}
-
-/* Menu item for showing status */
-static void
-on_show_window_activate (GtkWidget *item, gpointer data)
-{
-    window_show ();
-}
-
-static void 
-on_settings_childsetup (gpointer unused)
-{
-    seahorse_agent_childsetup ();
-}
-
-static void
-on_settings_activate (GtkWidget *item, gpointer data)
-{
-    GError *err = NULL;
-    gchar* args[3];
-
-    args[0] = "seahorse-preferences";
-    args[1] = "--cache";
-    args[2] = NULL;
-
-    g_spawn_async (NULL, args, NULL, G_SPAWN_SEARCH_PATH, 
-                   on_settings_childsetup, NULL, NULL, &err);
-
-    if (err != NULL) {
-        g_warning ("couldn't execute seahorse-preferences: %s", err->message);
-        g_error_free (err);
-    }
-}
-
-/* Called when icon clicked */
-G_MODULE_EXPORT static void
-tray_activate (GtkStatusIcon *icon, void *data)
-{
-    if (g_window)
-        window_destroy ();
-    else
-        window_show ();
-}
-
-/* Called when icon clicked */
-G_MODULE_EXPORT static void
-tray_popup_menu (GtkStatusIcon *icon, guint button, guint32 timestamp, void *data)
-{
-    GtkWidget *w;
-
-    w = GTK_WIDGET (seahorse_widget_get_widget (g_window, "clear_cache"));
-    g_object_connect (G_OBJECT (w), "activate", G_CALLBACK (on_clear_cache_activate), NULL);
-    
-    w = GTK_WIDGET (seahorse_widget_get_widget (g_window, "show_window"));
-    g_object_connect (G_OBJECT (w), "activate", G_CALLBACK (on_show_window_activate), NULL);
-
-    w = GTK_WIDGET (seahorse_widget_get_widget (g_window, "cache_settings"));
-    g_object_connect (G_OBJECT (w), "activate", G_CALLBACK (on_settings_activate), NULL);
-    
-    w = GTK_WIDGET (seahorse_widget_get_widget (g_window, "context-menu"));
-    
-    gtk_menu_popup (GTK_MENU (w), NULL, NULL,
-                    gtk_status_icon_position_menu, icon, button, timestamp);
-    
-    if (button == 0)
-        gtk_menu_shell_select_first (GTK_MENU_SHELL (w), FALSE);
-}
-
-/* Remove tray icon */
-static void
-docklet_destroy ()
-{
-    if (g_docklet) {
-        g_object_unref (G_OBJECT (g_docklet));
-        g_docklet = NULL;
-    }
-}
-
-static void
-docklet_create ()
-{
-    if (g_docklet) {
-        /* 
-         * If this is being called when a tray icon exists, it's 
-         * because something messed up. try destroying it before 
-         * we proceed, although docklet_refcount may be all hosed. 
-         * hopefully won't happen. 
-         */
-
-        g_warning ("trying to create icon but it already exists");
-        docklet_destroy ();
-    }
-
-    g_docklet = gtk_status_icon_new_from_stock (GTK_STOCK_DIALOG_AUTHENTICATION);
-
-    g_signal_connect (G_OBJECT (g_docklet), "activate", G_CALLBACK (tray_activate), NULL);
-    g_signal_connect (G_OBJECT (g_docklet), "popup-menu", G_CALLBACK (tray_popup_menu), NULL);
-    gtk_status_icon_set_visible (g_docklet, TRUE);
-}
-
-/* Called when the display gconf key changes */
-static void
-gconf_notify (GConfClient *client, guint id, GConfEntry *entry, gpointer data)
-{
-    if (g_str_equal (SETTING_DISPLAY, gconf_entry_get_key (entry)))
-        seahorse_agent_status_update ();
-}
-
-/* -----------------------------------------------------------------------------
- * PUBLIC
- */
-
-/* Initialize the status code */
-void
-seahorse_agent_status_init ()
-{
-    seahorse_agent_status_update ();
-
-    /* Listen for changes on the AUTH key */
-    g_notify_id = seahorse_gconf_notify (SETTING_DISPLAY, gconf_notify, NULL);
-}
-
-/* Called when quiting */
-void
-seahorse_agent_status_cleanup ()
-{
-    docklet_destroy ();
-
-    if (g_window)
-        window_destroy ();
-
-    if (g_notify_id) {
-        seahorse_gconf_unnotify (g_notify_id);
-        g_notify_id = 0;
-    }
-}
-
-/* Cache calls this when changes occur */
-void
-seahorse_agent_status_update ()
-{
-    gboolean have = seahorse_gconf_get_boolean (SETTING_DISPLAY);
-
-    if (have) {
-        /* Only show when allowed to display, and have cached keys */
-        have = (seahorse_agent_cache_count () > 0);
-    }
-    
-    if (have && !g_docklet)
-        docklet_create ();
-
-    else if (!have && g_docklet)
-        docklet_destroy ();
-
-    if (g_window)
-        window_update_keys ();
-}
-
diff --git a/agent/seahorse-agent.1 b/agent/seahorse-agent.1
deleted file mode 100644
index dc7388e..0000000
--- a/agent/seahorse-agent.1
+++ b/dev/null
@@ -1,111 +0,0 @@
-.\"
-.\" This page was created on 2006-05-06 19:28:06 by makeman.pl
-.\" ``makeman.pl'' is part of the ``MakeMan'' project.
-.\" For more information, please see http://mama.sourceforge.net
-.\"
-.TH seahorse\-agent 1 "May 04, 2006" "seahorse" "GNOME" 
-
-.SH NAME
-seahorse\-agent \- seahorse pass phrase caching agent
-
-.SH SYNOPSIS
-\fBseahorse\-agent\fR
-[ \fIOPTION\fR... ] 
-
-.SH "DESCRIPTION"
-.PP
-Seahorse is a GNOME application for managing encryption keys. 
-.PP
-This is the agent program for seahorse which keeps a temporary secure
-storage of your pass phrases. It also works with the SSH agent to prompt
-you for SSH passphrases.
-
-.SH "OPTIONS"
-
-.SS "Help options"
-.\" Begin List
-.TP
-\fB\-?, \-\-help\fR
-Show summary of all options and exit.
-.TP
-\fB\-\-usage\fR
-Display brief usage message and exit.
-.\" End List
-
-.SS "Application options"
-.\" Begin List
-.TP
-\fB\-c, \-\-cshell\fR
-Print variables in for a C type shell.
-.TP
-\fB\-d, \-\-no\-daemonize\fR
-Do not daemonize seahorse\-agent.
-.TP
-\fB\-A, \-\-any\-display\fR
-Don't try to make sure requests only come from the X display on which seahorse\-agent was started.
-.TP
-\fB\-\-v, \-\-variables\fR
-Display variables instead of editing gpg.conf.
-.\" End List
-
-.SS "Additional options"
-.PP
-In addition, the usual GTK+ and GNOME command line options apply. See the output of \-\-help for details.
-
-.SH "VERSION"
-.PP
-This man page describes \fBseahorse\-agent\fR version 0.9.
-
-.SH "BUGS"
-.PP
-If you find a bug, please report it at 
- \fIhttp://bugzilla.gnome.org/enter_bug.cgi?product=seahorse\fR.
-
-.SH "AUTHORS"
-.PP
-Jacob
-Perkins
-<jap1@users.sourceforge.net>
-.PP
-Jose Carlos Garcia
-Sogo
-<jsogo@users.sourceforge.net>
-.PP
-Jean
-Schurger
-<jk24@users.sourceforge.net>
-.PP
-Stef
-Walter
-<stef@memberwebs.com>
-.PP
-Adam
-Schreiber
-<sadam@clemson.edu>
-.PP
-This man page was originally written by
-Michael
-Mende
-<debian@menole.net>
-for the Debian system.
-
-.SH "COPYRIGHT"
-.PP
-.br
-Copyright (C) 2001, 2002 Jose Carlos Garcia Sogo
-.br
-Copyright (C) 2002, 2003 Jacob Perkins
-.br
-Copyright (C) 2004, 2006 Nate Nielsen, Adam Schreiber
-
-.SH "LICENSE"
-.PP
-.br
-You are free to distribute this software under the terms of the GNU General Public License.
-.br
-Documentation and help files are covered by GFDL license.
-
-.SH "SEE ALSO"
-.PP
-\fBseahorse-tool(1)\fR,
-\fBseahorse-daemon(1)\fR
diff --git a/agent/seahorse-agent.c b/agent/seahorse-agent.c
deleted file mode 100644
index b2a6f6d..0000000
--- a/agent/seahorse-agent.c
+++ b/dev/null
@@ -1,168 +0,0 @@
-/*
- * Seahorse
- *
- * Copyright (C) 2004 Stefan Walter
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the
- * Free Software Foundation, Inc.,
- * 59 Temple Place, Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-#include <sys/types.h>
-#include <sys/param.h>
-#include <sys/signal.h>
-
-#include <stddef.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <err.h>
-#include <unistd.h>
-#include <syslog.h>
-#include <fcntl.h>
-
-#include "seahorse-agent.h"
-#include "seahorse-gpg-options.h"
-#include "seahorse-passphrase.h"
-
-gboolean seahorse_agent_cshell = FALSE;
-gboolean seahorse_agent_execvars = FALSE;
-
-static gboolean seahorse_agent_enabled = FALSE;
-
-/* PUBLISHING AGENT INFO ---------------------------------------------------- */
-
-/* Print out the socket name info: <name>:<pid>:<protocol_version> */
-static void
-process_display (const gchar *socket, pid_t pid)
-{
-    if (seahorse_agent_cshell) {
-        fprintf (stdout, "setenv GPG_AGENT_INFO %s:%lu:1\n",
-                 socket, (long unsigned int) pid);
-    } else {
-        fprintf (stdout, "GPG_AGENT_INFO=%s:%lu:1; export GPG_AGENT_INFO\n",
-                 socket, (long unsigned int) pid);
-    }
-
-    fflush (stdout);
-}
-
-static void 
-process_setenv (const gchar *socket, pid_t pid)
-{
-    gchar *var;
-
-    /* Memory doesn't need to be freed */
-    var = g_strdup_printf ("%s:%lu:1", socket, (long unsigned int) pid);
-    g_setenv ("GPG_AGENT_INFO", var, TRUE);
-}
-
-/* 
- * Called before forking as a daemon, creates the GPG agent 
- * socket. This socket path needs to be present and decided
- * on before the fork.
- */
-void
-seahorse_agent_prefork ()
-{
-    /* Detect and see if there's an agent */
-    switch (seahorse_passphrase_detect_agent ()) {
-    case SEAHORSE_AGENT_NONE:
-        break;
-    default:
-        g_message ("Another GPG agent already running\n");
-        return;
-    }
-    
-    seahorse_agent_enabled = TRUE;
-    if (seahorse_agent_io_socket () == -1)
-        _exit (1); /* Message already printed */
-}
-
-/* 
- * Called after forking off the agent daemon child. At this 
- * point we communicate the socket path to the environment
- * as requested.
- */
-void
-seahorse_agent_postfork (pid_t child)
-{
-    const gchar *socket;
-
-    if(!seahorse_agent_enabled)
-        return;
-    
-    socket = seahorse_agent_io_get_socket ();
-    g_return_if_fail (socket != NULL);
-    
-    /* If any of these fail, they simply exit */
-    if(seahorse_agent_execvars)
-        process_setenv (socket, child);
-    else 
-        process_display (socket, child);
-}
-
-/* 
- * Called when we run another program (such as seahorse-preferences)
- * to setup the environment appropriately for that process.
- */
-void 
-seahorse_agent_childsetup ()
-{
-    const gchar *socket = seahorse_agent_io_get_socket ();
-    g_return_if_fail (socket != NULL);
-
-    process_setenv (socket, getpid ());
-}
-
-gboolean
-seahorse_agent_init ()
-{
-    if(!seahorse_agent_enabled)
-        return TRUE;
-    
-    if (seahorse_agent_io_init () == -1)
-        return FALSE;           /* message already printed */
-    
-    /* Initialize our sub systems */
-    seahorse_agent_actions_init ();
-    seahorse_agent_cache_init ();
-    seahorse_agent_status_init ();
-    
-    return TRUE;
-}
-
-gboolean
-seahorse_agent_uninit (gpointer *data)
-{
-    if(!seahorse_agent_enabled)
-        return FALSE;
-
-    /* If any windows are open this closes them */
-    seahorse_agent_prompt_cleanup ();
-    seahorse_agent_status_cleanup ();
-
-    /* Uninitialize all subsystems */
-    seahorse_agent_cache_uninit ();
-    seahorse_agent_actions_uninit ();
-    seahorse_agent_io_uninit ();
-    
-    return FALSE;
-}
-
-void
-seahorse_agent_exit ()
-{
-    seahorse_agent_uninit (NULL);
-}
diff --git a/agent/seahorse-agent.h b/agent/seahorse-agent.h
deleted file mode 100644
index 0be3209..0000000
--- a/agent/seahorse-agent.h
+++ b/dev/null
@@ -1,135 +0,0 @@
-/*
- * Seahorse
- *
- * Copyright (C) 2004 Stefan Walter
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the
- * Free Software Foundation, Inc.,
- * 59 Temple Place, Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef __SEAHORSE_AGENT_H__
-#define __SEAHORSE_AGENT_H__
-
-#include <glib.h>
-#include <gconf/gconf-client.h>
-#include <gconf/gconf.h>
-
-#ifndef KL
-#define KL(s)               ((sizeof(s) - 1) / sizeof(s[0]))
-#endif
-
-/* -----------------------------------------------------------------------------
- * seahorse-agent gconf keys
- */
-
-#define AGENT_SETTINGS      "/apps/seahorse/agent"
-#define SETTING_CACHE       AGENT_SETTINGS "/cache_enabled"
-#define SETTING_METHOD      AGENT_SETTINGS "/cache_method"
-#define SETTING_TTL         AGENT_SETTINGS "/cache_ttl"
-#define SETTING_EXPIRE      AGENT_SETTINGS "/cache_expire"
-#define SETTING_AUTH        AGENT_SETTINGS "/cache_authorize"
-#define SETTING_DISPLAY     AGENT_SETTINGS "/cache_display"
-#define METHOD_GNOME        "gnome"
-
-/* -----------------------------------------------------------------------------
- * seahorse-agent.c
- */
-
-/* Called from the original process before and after fork */
-void seahorse_agent_prefork ();
-void seahorse_agent_postfork (pid_t child);
-void seahorse_agent_childsetup ();
-
-/* Called in the new child process */
-gboolean seahorse_agent_init ();
-gboolean seahorse_agent_uninit (gpointer *data);
-void     seahorse_agent_exit ();
-
-/* Global options to set from the command line */
-extern gboolean seahorse_agent_cshell;
-extern gboolean seahorse_agent_execvars;
-extern gboolean seahorse_agent_any_display;
-
-/* -----------------------------------------------------------------------------
- * seahorse-agent-io.c
- */
-
-struct _SeahorseAgentConn;
-typedef struct _SeahorseAgentConn SeahorseAgentConn;
-
-int seahorse_agent_io_socket ();
-const gchar* seahorse_agent_io_get_socket ();
-int seahorse_agent_io_init ();
-void seahorse_agent_io_uninit ();
-void seahorse_agent_io_reply (SeahorseAgentConn *rq, gboolean ok, const gchar *response);
-void seahorse_agent_io_data (SeahorseAgentConn *cn, const gchar *data);
-
-/* -----------------------------------------------------------------------------
- * seahorse-agent-actions.c
- */
-
-#define SEAHORSE_AGENT_PASS_AS_DATA    0x00000001
-#define SEAHORSE_AGENT_REPEAT          0x00000002
-
-typedef struct _SeahorseAgentPassReq {
-    const gchar *id;
-    const gchar *errmsg;
-    const gchar *prompt;
-    const gchar *description;
-    SeahorseAgentConn *request;
-    guint32 flags;
-} SeahorseAgentPassReq;
-
-void seahorse_agent_actions_init ();
-void seahorse_agent_actions_uninit ();
-void seahorse_agent_actions_getpass (SeahorseAgentConn *rq, guint32 flags, gchar *id,
-                                     gchar *errmsg, gchar *prompt, gchar *desc);
-void seahorse_agent_actions_clrpass (SeahorseAgentConn *rq, gchar *id);
-void seahorse_agent_actions_doneauth (SeahorseAgentPassReq *pr, gboolean authorized);
-void seahorse_agent_actions_donepass (SeahorseAgentPassReq *pr, const gchar *pass);
-void seahorse_agent_actions_nextgui ();
-
-/* -----------------------------------------------------------------------------
- * seahorse-agent-cache.c
- */
-
-void seahorse_agent_cache_init ();
-void seahorse_agent_cache_uninit ();
-const gchar *seahorse_agent_cache_get (const gchar *id);
-void seahorse_agent_cache_set (const gchar *id, const gchar *pass, gboolean lock);
-gboolean seahorse_agent_cache_has (const gchar *id, gboolean lock);
-void seahorse_agent_cache_clear (const gchar *id);
-void seahorse_agent_cache_clearall ();
-guint seahorse_agent_cache_count ();
-GList* seahorse_agent_cache_get_key_names ();
-
-/* -----------------------------------------------------------------------------
- * seahorse-agent-prompt.c
- */
-
-gboolean seahorse_agent_prompt_have ();
-void seahorse_agent_prompt_pass (SeahorseAgentPassReq *pr);
-void seahorse_agent_prompt_auth (SeahorseAgentPassReq *pr);
-void seahorse_agent_prompt_cleanup ();
-
-/* -----------------------------------------------------------------------------
- * seahorse-agent-status.c
- */
-
-void seahorse_agent_status_init ();
-void seahorse_agent_status_cleanup ();
-void seahorse_agent_status_update ();
-
-#endif /* __SEAHORSE_AGENT_H__ */
diff --git a/configure.in b/configure.in
index 61f332c..d467da3 100644
--- a/configure.in
+++ b/configure.in
@@ -224,33 +224,6 @@ fi
 
 AM_CONDITIONAL(WITH_NAUTILUS_EXT, test "$with_nautilus_ext" = "yes")
 
-
-dnl ****************************************************************************
-dnl AGENT
-dnl ****************************************************************************
-
-# Allow agent to be disabled
-AC_ARG_ENABLE(agent, 
-        AC_HELP_STRING([--disable-agent],
-        [Don't compile agent for passphrase caching]))
-
-if test "$enable_agent" = "no"; then
-    echo "disabling password caching agent"
-else
-
-    enable_agent=yes
-    echo "enabling password caching agent"
-    
-    AC_DEFINE_UNQUOTED(WITH_AGENT, 1, [Compile password caching 'agent' code])
-    
-    AC_SUBST([AGENT_CFLAGS])
-    AC_SUBST([AGENT_LIBS])
-    
-fi
-
-AM_CONDITIONAL(WITH_AGENT, test "$enable_agent" != "no")
-
-
 dnl ****************************************************************************
 dnl GNOME-KEYRING
 dnl ****************************************************************************
@@ -624,7 +597,6 @@ pixmaps/Makefile
 pixmaps/22x22/Makefile
 pixmaps/48x48/Makefile
 pixmaps/scalable/Makefile
-agent/Makefile
 plugins/Makefile
 plugins/applet/Makefile
 plugins/applet/docs/Makefile
@@ -651,6 +623,5 @@ Plugins:
   GEdit (v >= 2.14):     $with_gedit_plugin
   Panel Applet:          $with_panel_applet
   Nautilus:              $with_nautilus_ext
-  Seahorse Agent:        $enable_agent
 Notification Support:    $enable_libnotify
 "
diff --git a/help/C/seahorse-plugins.xml b/help/C/seahorse-plugins.xml
index 48a6070..9000cf2 100644
--- a/help/C/seahorse-plugins.xml
+++ b/help/C/seahorse-plugins.xml
@@ -477,61 +477,6 @@
 	  </varlistentry>
 	</variablelist>
       </sect3>
-      
-      <sect3 id="password-cache">
-	<title>Passphrase Cache</title>
-	<para>
-	  Enabling the passphrase caching ability will allow you to 
-	  perform many operations that require entering your passphrase without 
-	  re-entering it every time. <command>seahorse-agent</command> takes the 
-	  place of <command>gpg-agent</command>. Letting the cached passphrases 
-	  expire is usually a good idea. This will then require re-entering your 
-	  passphrase, but adds security.
-	</para>
-	<variablelist>
-	  <varlistentry>
-	    <term><guilabel>Never remember passphrases</guilabel></term>
-	    <listitem>
-	      <para>
-		Sets to not remember any passphrase.
-	      </para>
-	    </listitem>
-	  </varlistentry>
-	  <varlistentry>
-	    <term><guilabel>Remember passphrases for ... minutes</guilabel></term>
-	    <listitem>
-	      <para>
-		Sets the amount of time, in minutes, for storing passphrases. 
-		Use the spin box to set the desired time.
-	      </para>
-	    </listitem>
-	  </varlistentry>
-	  <varlistentry>
-	    <term><guilabel>Always remember passphrases whenever logged in</guilabel></term>
-	    <listitem>
-	      <para>
-		Sets to remember any passphrases whenever you are logged in the session.
-	      </para>
-	    </listitem>
-	  </varlistentry>
-	  <varlistentry>
-	    <term><guilabel>Ask me before using a cached passphrase</guilabel></term>
-	    <listitem>
-	      <para>
-		Sets to ask you before using a stored passphrase.
-	      </para>
-	    </listitem>
-	  </varlistentry>
-	  <varlistentry>
-	    <term><guilabel>Automatically load Secure Shell keys</guilabel></term>
-	    <listitem>
-	      <para>
-		Sets to automatically cache any Secure Shell key.
-	      </para>
-	    </listitem>
-	  </varlistentry>
-	</variablelist>
-      </sect3>   
     </sect2>
   </sect1>
       
diff --git a/libseahorse/Makefile.am b/libseahorse/Makefile.am
index e0ae1b4..6007703 100644
--- a/libseahorse/Makefile.am
+++ b/libseahorse/Makefile.am
@@ -20,12 +20,6 @@ noinst_LIBRARIES = libseahorse.a
 BUILT_SOURCES = \
 	seahorse-marshal.c seahorse-marshal.h
 
-if WITH_AGENT
-AGENT_SRCS = seahorse-prefs-cache.c
-else
-AGENT_SRCS = 
-endif
-
 libseahorse_a_SOURCES = \
 	seahorse-pgp-operation.c seahorse-pgp-operation.h \
 	seahorse-widget.c seahorse-widget.h \
@@ -46,8 +40,7 @@ libseahorse_a_SOURCES = \
 	seahorse-secure-buffer.c seahorse-secure-buffer.h \
 	seahorse-algo.c seahorse-algo.h \
 	seahorse-unix-signal.c seahorse-unix-signal.h \
-	$(BUILT_SOURCES) \
-	$(AGENT_SRCS)
+	$(BUILT_SOURCES)
 
 seahorse-marshal.h: seahorse-marshal.list $(GLIB_GENMARSHAL)
 	$(GLIB_GENMARSHAL) $< --header --prefix=seahorse_marshal > $@
diff --git a/libseahorse/seahorse-passphrase.c b/libseahorse/seahorse-passphrase.c
index a33d2b9..821c9d1 100644
--- a/libseahorse/seahorse-passphrase.c
+++ b/libseahorse/seahorse-passphrase.c
@@ -51,7 +51,6 @@
 #include "seahorse-passphrase.h"
 #include "seahorse-secure-buffer.h"
 #include "seahorse-gpg-options.h"
-#include "agent/seahorse-agent.h"
 
 #define HIG_SMALL      6        /* gnome hig small space in pixels */
 #define HIG_LARGE     12        /* gnome hig large space in pixels */
@@ -392,167 +391,3 @@ seahorse_passphrase_get (gconstpointer dummy, const gchar *passphrase_hint,
     gtk_widget_destroy (GTK_WIDGET (dialog));
     return err;
 }
-
-/* -----------------------------------------------------------------------------
- * GPG AGENT 
- */
-
-/* Check if given process is running */
-static gboolean
-is_pid_running (pid_t pid)
-{
-    /* 
-     * We try to send it a harmless signal. Note that this won't
-     * work when sending to another users process. But other users
-     * shouldn't be running agent for this user anyway.
-     */
-    return (kill (pid, SIGWINCH) != -1);
-}
-
-/* Check if the server at the other end of the socket is our agent */
-static SeahorseAgentType
-check_agent_id (int fd)
-{
-    SeahorseAgentType ret = SEAHORSE_AGENT_NONE;
-    GIOChannel *io;
-    gchar *t;
-    GError *err = NULL;
-
-    io = g_io_channel_unix_new (fd);
-
-    /* Server always sends a response first */
-    if (g_io_channel_read_line (io, &t, NULL, NULL, NULL) == G_IO_STATUS_NORMAL && t) {
-        g_strstrip (t);
-        if (g_str_has_prefix (t, "OK"))
-            ret = SEAHORSE_AGENT_OTHER;
-        g_free (t);
-
-        /* Send back request for info */
-        if (ret != SEAHORSE_AGENT_NONE &&
-            g_io_channel_write_chars (io, "AGENT_ID\n", -1, NULL,
-                                      &err) == G_IO_STATUS_NORMAL
-            && g_io_channel_flush (io, &err) == G_IO_STATUS_NORMAL
-            && g_io_channel_read_line (io, &t, NULL, NULL,
-                                       &err) == G_IO_STATUS_NORMAL && t) {
-            g_strstrip (t);
-            if (g_str_has_prefix (t, "OK seahorse-agent"))
-                ret = SEAHORSE_AGENT_SEAHORSE;
-            g_free (t);
-        }
-    }
-
-    g_io_channel_shutdown (io, FALSE, NULL);
-    g_io_channel_unref (io);
-    
-    if (err) {
-        g_warning ("couldn't check GPG agent: %s", err->message);
-        g_error_free (err);
-        ret = SEAHORSE_AGENT_UNKNOWN;
-    }
-    
-    return ret;
-}
-
-/* Open a connection to our agent */
-static SeahorseAgentType
-get_listening_agent_type (const gchar *sockname)
-{
-    struct sockaddr_un addr;
-    SeahorseAgentType ret;
-    int len;
-    int fd;
-
-    /* Agent is always a unix socket */
-    fd = socket (AF_UNIX, SOCK_STREAM, 0);
-    if (fd == -1)
-        return SEAHORSE_AGENT_UNKNOWN;
-    
-    memset (&addr, 0, sizeof (addr));
-    addr.sun_family = AF_UNIX;
-    g_strlcpy (addr.sun_path, sockname, sizeof (addr.sun_path));
-    len = offsetof (struct sockaddr_un, sun_path) + strlen (addr.sun_path) + 1;
-
-    if (connect (fd, (const struct sockaddr *) &addr, len) == 0)
-        ret = check_agent_id (fd);
-    else
-        ret = SEAHORSE_AGENT_UNKNOWN;
-
-    shutdown (fd, SHUT_RDWR);
-    close (fd);
-    return ret;
-}
-
-/* Given an agent info string make sure it's running and is our agent */
-static SeahorseAgentType
-check_agent_info (const gchar *agent_info)
-{
-    SeahorseAgentType ret = SEAHORSE_AGENT_NONE;
-    gchar **info;
-    gchar **t;
-    int i;
-
-    gchar *socket;
-    pid_t pid;
-    gint version;
-
-    info = g_strsplit (agent_info, ":", 3);
-
-    for (i = 0, t = info; *t && i < 3; t++, i++) {
-        switch (i) {
-            /* The socket name first */
-        case 0:
-            socket = *t;
-            break;
-
-            /* Then the process id */
-        case 1:
-            pid = (pid_t) atoi (*t);
-            break;
-
-            /* Then the protocol version */
-        case 2:
-            version = (gint) atoi (*t);
-            break;
-
-        default:
-            g_assert_not_reached ();
-        };
-    }
-
-    if (version == 1 && pid != 0 && is_pid_running (pid))
-        ret = get_listening_agent_type (socket);
-        
-    g_strfreev (info);
-    return ret;
-}
-
-static SeahorseAgentType
-gpg_detect_agent ()
-{
-    gchar *value = NULL;
-
-    /* Seahorse edits gpg.conf by default */
-    seahorse_gpg_options_find ("gpg-agent-info", &value, NULL);
-    if (value != NULL) {
-        SeahorseAgentType ret = check_agent_info (value);
-        g_free (value);
-        return ret;
-    }
-
-    /* The user probably set this up on their own */
-    value = (gchar*)g_getenv ("GPG_AGENT_INFO");
-    if (value != NULL)
-        return check_agent_info (value);
-
-    return SEAHORSE_AGENT_NONE;
-}
-
-/* -------------------------------------------------------------------------- */
-
-/* Check if the agent is running */
-SeahorseAgentType
-seahorse_passphrase_detect_agent (void)
-{
-    return gpg_detect_agent ();
-}
-
diff --git a/libseahorse/seahorse-passphrase.h b/libseahorse/seahorse-passphrase.h
index e34e84b..57bf51b 100644
--- a/libseahorse/seahorse-passphrase.h
+++ b/libseahorse/seahorse-passphrase.h
@@ -43,13 +43,4 @@ gpgme_error_t   seahorse_passphrase_get             (gconstpointer dummy,
                                                      const char* passphrase_info, 
                                                      int prev_bad, int fd);
 
-typedef enum {
-    SEAHORSE_AGENT_UNKNOWN,
-    SEAHORSE_AGENT_NONE,
-    SEAHORSE_AGENT_OTHER,
-    SEAHORSE_AGENT_SEAHORSE
-} SeahorseAgentType;
-
-SeahorseAgentType seahorse_passphrase_detect_agent (void);
-
 #endif /* __SEAHORSE_PASSPHRASE__ */
diff --git a/libseahorse/seahorse-prefs-cache.c b/libseahorse/seahorse-prefs-cache.c
deleted file mode 100644
index e7ab74a..0000000
--- a/libseahorse/seahorse-prefs-cache.c
+++ b/dev/null
@@ -1,278 +0,0 @@
-/*
- * Seahorse
- *
- * Copyright (C) 2004 Stefan Walter
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the
- * Free Software Foundation, Inc.,
- * 59 Temple Place, Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-#include <sys/types.h>
-#include <sys/param.h>
-#include <sys/wait.h>
-
-#include <stdlib.h>
-#include <gtk/gtk.h>
-
-#define DBUS_API_SUBJECT_TO_CHANGE
-#include <dbus/dbus.h>
-
-#include "seahorse-widget.h"
-#include "seahorse-gpg-options.h"
-#include "seahorse-gconf.h"
-#include "seahorse-util.h"
-#include "seahorse-check-button-control.h"
-#include "agent/seahorse-agent.h"
-#include "seahorse-passphrase.h"
-
-#define METHOD_INTERNAL     "internal"
-
-/* -----------------------------------------------------------------------------
- * GPG CONF
- */
-
-static const char* gpg_confs[] = {
-    "use-agent",
-    NULL
-};
-
-/* Loads the main 'use-agent' gpg.conf into gconf 'cache_enabled */
-static void 
-load_gpg_conf ()
-{
-    GError *error = NULL;
-    char *values[2];
-
-    if (!seahorse_gpg_options_find_vals (gpg_confs, values, &error)) {
-        g_warning ("couldn't read gpg 'use-agent' configuration: %s", error ? error->message : "");
-	  	g_clear_error (&error);
-        return;
-    }
-
-    seahorse_gconf_set_boolean (SETTING_CACHE, values[0] ? TRUE : FALSE);
-}
-
-/* Saves the gconf 'cache_enabled' setting into 'use-agent' in gpg.conf */
-static void 
-save_gpg_conf ()
-{
-    GError *error = NULL;
-    gboolean set;
-    char *values[2];
-
-    set = seahorse_gconf_get_boolean (SETTING_CACHE);
-
-    if (!seahorse_gpg_options_find_vals (gpg_confs, values, &error)) {
-        g_warning ("couldn't read gpg 'use-agent' configuration: %s", error ? error->message : "");
-	  	g_clear_error (&error);
-        return;
-    }
-
-    /* Don't modify needlessly */
-    if ((values[0] ? TRUE : FALSE) == set)
-        return;
-
-    values[0] = set ? "" : NULL;
-    values[1] = NULL; /* null teriminate */
-
-    if (!seahorse_gpg_options_change_vals (gpg_confs, values, &error)) {
-        g_warning ("couldn't modify gpg 'use-agent' configuration: %s", error ? error->message : "");
-        g_clear_error (&error);
-    }
-}
-
-/* -----------------------------------------------------------------------------
- *  CONTROLS
- */
-
-static void
-update_cache_choices (const char *gconf_key, SeahorseWidget *swidget)
-{
-    GtkWidget *widget;
-    gchar *str;
-    gint ttl;
-    gboolean set;
-    
-    if (g_strcmp0 (gconf_key, SETTING_CACHE) == 0) {
-        
-        set = seahorse_gconf_get_boolean (SETTING_CACHE);
-        if (!set) {
-            widget = seahorse_widget_get_widget (swidget, "no-cache");
-            g_return_if_fail (widget != NULL);
-            gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), TRUE);
-        }
-        
-        return;
-    }
-    
-    if (g_strcmp0 (gconf_key, SETTING_METHOD) == 0) {
-        
-        str = seahorse_gconf_get_string (SETTING_METHOD);
-        if (!str || g_strcmp0 (str, METHOD_GNOME) != 0)
-            widget = seahorse_widget_get_widget (swidget, "session-cache");
-        else
-            widget = seahorse_widget_get_widget (swidget, "keyring-cache");
-        g_free (str);
-
-        g_return_if_fail (widget != NULL);
-        gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), TRUE);
-        
-        return;
-    }
-    
-    if (g_strcmp0 (gconf_key, SETTING_TTL) == 0) {
-        
-        ttl = seahorse_gconf_get_integer (SETTING_TTL);
-        if (ttl < 0)
-            ttl = 0;
-        widget = seahorse_widget_get_widget (swidget, "ttl");
-        g_return_if_fail (widget != NULL);
-        gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), ttl);
-        
-        return;
-    }
-}
-
-static void
-cache_gconf_notify (GConfClient *client, guint id, 
-              GConfEntry *entry, SeahorseWidget *swidget)
-{
-    update_cache_choices (gconf_entry_get_key (entry), swidget);
-}
-
-static void
-save_cache_choices (GtkWidget *unused, SeahorseWidget *swidget)
-{
-    GtkWidget *widget, *widget_ttl;
-    int ttl;
-    
-    widget_ttl = seahorse_widget_get_widget (swidget, "ttl");
-    g_return_if_fail (widget_ttl != NULL);
-    
-    widget = seahorse_widget_get_widget (swidget, "no-cache");
-    g_return_if_fail (widget != NULL);
-    
-    /* No cache */
-    if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget))) {
-        seahorse_gconf_set_boolean (SETTING_CACHE, FALSE);
-        gtk_widget_set_sensitive (widget_ttl, FALSE);
-        save_gpg_conf ();        
-        return;
-    }
-    
-    widget = seahorse_widget_get_widget (swidget, "session-cache");
-    g_return_if_fail (widget != NULL);
-    
-    /* Session cache */
-    if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget))) {
-        seahorse_gconf_set_boolean (SETTING_CACHE, TRUE);
-        seahorse_gconf_set_string (SETTING_METHOD, METHOD_INTERNAL);
-        gtk_widget_set_sensitive (widget_ttl, TRUE);
-        ttl = gtk_spin_button_get_value_as_int (GTK_SPIN_BUTTON (widget_ttl));
-        seahorse_gconf_set_boolean (SETTING_EXPIRE, ttl > 0 ? TRUE : FALSE);
-        seahorse_gconf_set_integer (SETTING_TTL, ttl);
-        save_gpg_conf ();
-        return;
-    }
-    
-    widget = seahorse_widget_get_widget (swidget, "keyring-cache");
-    g_return_if_fail (widget != NULL);
-    
-    /* gnome-keyring cache */
-    if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget))) {
-        seahorse_gconf_set_boolean (SETTING_CACHE, TRUE);
-        seahorse_gconf_set_string (SETTING_METHOD, METHOD_GNOME);
-        gtk_widget_set_sensitive (widget_ttl, FALSE);
-        seahorse_gconf_set_boolean (SETTING_EXPIRE, FALSE);
-        save_gpg_conf ();
-    }    
-}
-
-static void
-save_ttl (GtkSpinButton *spinner, SeahorseWidget *swidget)
-{
-    int ttl = gtk_spin_button_get_value_as_int (spinner);
-    if (ttl < 0)
-        ttl = 0;
-    seahorse_gconf_set_integer (SETTING_TTL, ttl);
-}
-
-/* Initialize the cache tab */
-void
-seahorse_prefs_cache (SeahorseWidget *swidget)
-{
-    GtkWidget *w;
-    
-    g_return_if_fail (swidget != NULL);
-
-    /* Update gconf from gpg.conf */
-    load_gpg_conf ();
-
-    /* Initial values, then listen */
-    update_cache_choices (SETTING_CACHE, swidget);
-    update_cache_choices (SETTING_METHOD, swidget);
-    update_cache_choices (SETTING_TTL, swidget);
-    seahorse_gconf_notify_lazy (AGENT_SETTINGS, (GConfClientNotifyFunc)cache_gconf_notify, 
-                                swidget, swidget);
-    
-    w = seahorse_widget_get_widget (swidget, "no-cache");
-    g_return_if_fail (w != NULL);
-    g_signal_connect_after (w, "toggled", G_CALLBACK (save_cache_choices), swidget);
-    
-    w = seahorse_widget_get_widget (swidget, "session-cache");
-    g_return_if_fail (w != NULL);
-    g_signal_connect_after (w, "toggled", G_CALLBACK (save_cache_choices), swidget);
-    
-    w = seahorse_widget_get_widget (swidget, "keyring-cache");
-    g_return_if_fail (w != NULL);
-    g_signal_connect_after (w, "toggled", G_CALLBACK (save_cache_choices), swidget);
-    
-    w = seahorse_widget_get_widget (swidget, "ttl");
-    g_return_if_fail (w != NULL);
-    g_signal_connect_after (w, "value-changed", G_CALLBACK (save_ttl), swidget);
-    
-    /* Authorize check button */
-    w = seahorse_widget_get_widget (swidget, "authorize");
-    g_return_if_fail (w != NULL);
-    seahorse_check_button_gconf_attach (GTK_CHECK_BUTTON (w), SETTING_AUTH);
-    
-    /* Display status check button */
-    w = seahorse_widget_get_widget (swidget, "display_status");
-    g_return_if_fail (w != NULL);
-    seahorse_check_button_gconf_attach (GTK_CHECK_BUTTON (w), SETTING_DISPLAY);
-
-    /* End -- Setup daemon button visuals */
-                                   
-    /* Disable GPG agent prefs if another agent is running or error */
-    switch (seahorse_passphrase_detect_agent ()) {
-    case SEAHORSE_AGENT_NONE:
-        break;
-        
-    case SEAHORSE_AGENT_UNKNOWN:
-    case SEAHORSE_AGENT_OTHER:
-        g_warning ("Invalid or no GPG agent is running. Disabling cache preferences.");
-        w = seahorse_widget_get_widget (swidget, "pgp-area");
-        if (w != NULL)
-            gtk_widget_hide (w);
-        w = seahorse_widget_get_widget (swidget, "pgp-message");
-        if (w != NULL)
-            gtk_widget_show (w);
-        break;
-
-    default:
-        break;
-    };
-}
diff --git a/libseahorse/seahorse-prefs.c b/libseahorse/seahorse-prefs.c
index 44ea4e9..e6acaab 100644
--- a/libseahorse/seahorse-prefs.c
+++ b/libseahorse/seahorse-prefs.c
@@ -35,9 +35,6 @@
 #include "seahorse-secure-buffer.h"
 #include "seahorse-widget.h"
 
-/* From seahorse-prefs-cache.c */
-void seahorse_prefs_cache (SeahorseWidget *widget);
-
 /* From sehorse-prefs-keyrings.c */
 void seahorse_prefs_keyrings (SeahorseWidget *widget);
 
@@ -111,14 +108,6 @@ seahorse_prefs_new (GtkWindow *parent)
                                       (GConfClientNotifyFunc)gconf_notification, GTK_COMBO_BOX (widget));
     g_signal_connect (widget, "destroy", G_CALLBACK (remove_gconf_notification), GINT_TO_POINTER (gconf_id));
     
-#ifdef WITH_AGENT   
-    seahorse_prefs_cache (swidget);
-#else
-    widget = GTK_WIDGET (seahorse_widget_get_widget (swidget, "cache-tab"));
-    g_return_val_if_fail (GTK_IS_WIDGET (widget), swidget);
-    seahorse_prefs_remove_tab (swidget, widget);
-#endif
-
     seahorse_widget_show (swidget);
     return swidget;
 }
diff --git a/libseahorse/seahorse-prefs.xml b/libseahorse/seahorse-prefs.xml
index 47ef0b6..aadcb5b 100644
--- a/libseahorse/seahorse-prefs.xml
+++ b/libseahorse/seahorse-prefs.xml
@@ -135,197 +135,6 @@
               </packing>
             </child>
             <child type="tab">
-              <object class="GtkLabel" id="label1">
-                <property name="visible">True</property>
-                <property name="label" translatable="yes">Encryption</property>
-              </object>
-              <packing>
-                <property name="tab_fill">False</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkVBox" id="cache-tab">
-                <property name="visible">True</property>
-                <property name="border_width">12</property>
-                <property name="spacing">18</property>
-                <child>
-                  <object class="GtkVBox" id="vbox26">
-                    <property name="visible">True</property>
-                    <property name="spacing">6</property>
-                    <child>
-                      <object class="GtkLabel" id="label15">
-                        <property name="visible">True</property>
-                        <property name="xalign">0</property>
-                        <property name="label" translatable="yes">&lt;b&gt;Remember PGP Passphrases&lt;/b&gt;</property>
-                        <property name="use_markup">True</property>
-                      </object>
-                      <packing>
-                        <property name="expand">False</property>
-                        <property name="fill">False</property>
-                        <property name="position">0</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkAlignment" id="pgp-message">
-                        <property name="left_padding">12</property>
-                        <child>
-                          <object class="GtkLabel" id="label18">
-                            <property name="visible">True</property>
-                            <property name="xalign">0</property>
-                            <property name="label" translatable="yes">&lt;i&gt;A supported PGP passphrase caching agent is not running.&lt;/i&gt;</property>
-                            <property name="use_markup">True</property>
-                          </object>
-                        </child>
-                      </object>
-                      <packing>
-                        <property name="position">1</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkAlignment" id="pgp-area">
-                        <property name="visible">True</property>
-                        <property name="left_padding">12</property>
-                        <child>
-                          <object class="GtkVBox" id="vbox12">
-                            <property name="visible">True</property>
-                            <property name="spacing">6</property>
-                            <child>
-                              <object class="GtkRadioButton" id="no-cache">
-                                <property name="label" translatable="yes">_Never remember passphrases</property>
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="receives_default">False</property>
-                                <property name="use_underline">True</property>
-                                <property name="draw_indicator">True</property>
-                              </object>
-                              <packing>
-                                <property name="expand">False</property>
-                                <property name="fill">False</property>
-                                <property name="position">0</property>
-                              </packing>
-                            </child>
-                            <child>
-                              <object class="GtkHBox" id="hbox9">
-                                <property name="visible">True</property>
-                                <property name="spacing">6</property>
-                                <child>
-                                  <object class="GtkRadioButton" id="session-cache">
-                                    <property name="label" translatable="yes">_Remember passphrases for</property>
-                                    <property name="visible">True</property>
-                                    <property name="can_focus">True</property>
-                                    <property name="receives_default">False</property>
-                                    <property name="use_underline">True</property>
-                                    <property name="draw_indicator">True</property>
-                                    <property name="group">no-cache</property>
-                                  </object>
-                                  <packing>
-                                    <property name="expand">False</property>
-                                    <property name="fill">False</property>
-                                    <property name="position">0</property>
-                                  </packing>
-                                </child>
-                                <child>
-                                  <object class="GtkSpinButton" id="ttl">
-                                    <property name="visible">True</property>
-                                    <property name="can_focus">True</property>
-                                    <property name="adjustment">adjustment1</property>
-                                    <property name="climb_rate">1</property>
-                                    <property name="numeric">True</property>
-                                  </object>
-                                  <packing>
-                                    <property name="expand">False</property>
-                                    <property name="position">1</property>
-                                  </packing>
-                                </child>
-                                <child>
-                                  <object class="GtkLabel" id="label4">
-                                    <property name="visible">True</property>
-                                    <property name="label" translatable="yes">minutes</property>
-                                  </object>
-                                  <packing>
-                                    <property name="expand">False</property>
-                                    <property name="fill">False</property>
-                                    <property name="position">2</property>
-                                  </packing>
-                                </child>
-                              </object>
-                              <packing>
-                                <property name="expand">False</property>
-                                <property name="fill">False</property>
-                                <property name="position">1</property>
-                              </packing>
-                            </child>
-                            <child>
-                              <object class="GtkRadioButton" id="keyring-cache">
-                                <property name="label" translatable="yes">_Always remember passphrases whenever logged in</property>
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="receives_default">False</property>
-                                <property name="use_underline">True</property>
-                                <property name="draw_indicator">True</property>
-                                <property name="group">no-cache</property>
-                              </object>
-                              <packing>
-                                <property name="expand">False</property>
-                                <property name="fill">False</property>
-                                <property name="position">2</property>
-                              </packing>
-                            </child>
-                            <child>
-                              <object class="GtkCheckButton" id="authorize">
-                                <property name="label" translatable="yes">As_k me before using a cached passphrase</property>
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="receives_default">False</property>
-                                <property name="use_underline">True</property>
-                                <property name="draw_indicator">True</property>
-                              </object>
-                              <packing>
-                                <property name="expand">False</property>
-                                <property name="fill">False</property>
-                                <property name="position">3</property>
-                              </packing>
-                            </child>
-                            <child>
-                              <object class="GtkCheckButton" id="display_status">
-                                <property name="label" translatable="yes">Show _icon in status area when passphrases are in memory</property>
-                                <property name="visible">True</property>
-                                <property name="can_focus">False</property>
-                                <property name="receives_default">False</property>
-                                <property name="use_underline">True</property>
-                                <property name="draw_indicator">True</property>
-                              </object>
-                              <packing>
-                                <property name="position">4</property>
-                              </packing>
-                            </child>
-                          </object>
-                        </child>
-                      </object>
-                      <packing>
-                        <property name="expand">False</property>
-                        <property name="position">2</property>
-                      </packing>
-                    </child>
-                  </object>
-                  <packing>
-                    <property name="expand">False</property>
-                    <property name="position">0</property>
-                  </packing>
-                </child>
-                <child>
-                  <placeholder/>
-                </child>
-                <child>
-                  <placeholder/>
-                </child>
-              </object>
-              <packing>
-                <property name="position">1</property>
-                <property name="tab_fill">False</property>
-              </packing>
-            </child>
-            <child type="tab">
               <object class="GtkLabel" id="label2">
                 <property name="label" translatable="yes">PGP Passphrases</property>
               </object>
diff --git a/libseahorse/seahorse-secure-memory.h b/libseahorse/seahorse-secure-memory.h
index 5df638d..2811155 100644
--- a/libseahorse/seahorse-secure-memory.h
+++ b/libseahorse/seahorse-secure-memory.h
@@ -1,5 +1,5 @@
 /* 
- * Quintuple Agent secure memory allocation
+ * Secure memory allocation
  * Copyright (C) 1998,1999 Free Software Foundation, Inc.
  * Copyright (C) 1999,2000 Robert Bihlmeyer <robbe@orcus.priv.at>
  *
diff --git a/plugins/nautilus/seahorse-pgp-preferences.c b/plugins/nautilus/seahorse-pgp-preferences.c
index cc8bae9..4ca0d35 100644
--- a/plugins/nautilus/seahorse-pgp-preferences.c
+++ b/plugins/nautilus/seahorse-pgp-preferences.c
@@ -29,16 +29,8 @@
 #include "seahorse-prefs.h"
 #include "seahorse-gtkstock.h"
 
-#ifdef WITH_AGENT
-static gboolean show_cache = FALSE;
-#endif
-
 static const GOptionEntry options[] = {
-#ifdef WITH_AGENT    
-	{ "cache", 'c', 0, G_OPTION_ARG_NONE, &show_cache,
-	    N_("For internal use"), NULL },
-#endif 
-    { NULL }
+	{ NULL }
 };
 
 G_MODULE_EXPORT static void
@@ -83,13 +75,6 @@ main (int argc, char **argv)
                       G_CALLBACK (destroyed), NULL);
     g_signal_connect (seahorse_widget_get_widget (swidget, "helpbutton1"), "clicked", G_CALLBACK (help_clicked), swidget);
 
-#ifdef WITH_AGENT	
-    if (show_cache) {
-        GtkWidget *tab = GTK_WIDGET (seahorse_widget_get_widget (swidget, "cache-tab"));
-        seahorse_prefs_select_tab (swidget, tab);
-    }
-#endif
-   
 	gtk_main();
 	return 0;
 }
diff --git a/po/POTFILES.in b/po/POTFILES.in
index dcfbc84..af211ae 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -1,12 +1,5 @@
 # List of source files containing translatable strings.
 # Please keep this file sorted alphabetically.
-agent/seahorse-agent-actions.c
-agent/seahorse-agent.c
-agent/seahorse-agent-cache.c
-[type: gettext/glade]agent/seahorse-agent-cache.xml
-agent/seahorse-agent-main.c
-agent/seahorse-agent-prompt.c
-agent/seahorse-agent-status.c
 data/seahorse-plugins.schemas.in
 libseahorse/seahorse-gpg-options.c
 [type: gettext/glade]libseahorse/seahorse-multi-encrypt.xml
@@ -14,7 +7,6 @@ libseahorse/seahorse-notification.c
 [type: gettext/glade]libseahorse/seahorse-notify.xml
 libseahorse/seahorse-passphrase.c
 libseahorse/seahorse-prefs.c
-libseahorse/seahorse-prefs-cache.c
 [type: gettext/glade]libseahorse/seahorse-prefs.xml
 [type: gettext/glade]libseahorse/seahorse-progress.xml
 libseahorse/seahorse-util.c
--
cgit v0.8.3.4
